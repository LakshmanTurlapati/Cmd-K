---
phase: 02-settings-configuration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src-tauri/Cargo.toml
  - src-tauri/src/lib.rs
  - src-tauri/src/commands/mod.rs
  - src-tauri/src/commands/keychain.rs
  - src-tauri/src/commands/xai.rs
  - src-tauri/src/commands/permissions.rs
  - src-tauri/capabilities/default.json
autonomous: true
requirements:
  - SETT-01
  - SETT-03

must_haves:
  truths:
    - "save_api_key Tauri command stores a string in macOS Keychain under com.lakshmanturlapati.cmd-k service"
    - "get_api_key Tauri command retrieves the stored key or returns null if none exists"
    - "delete_api_key Tauri command removes the key from Keychain"
    - "validate_and_fetch_models Tauri command calls xAI GET /v1/models and returns model list on 200 or error string on 401"
    - "open_accessibility_settings Tauri command opens macOS System Settings to the Accessibility pane"
    - "HTTP requests to api.x.ai are allowed by Tauri capabilities"
  artifacts:
    - path: "src-tauri/src/commands/keychain.rs"
      provides: "Keychain CRUD via keyring crate"
      exports: ["save_api_key", "get_api_key", "delete_api_key"]
    - path: "src-tauri/src/commands/xai.rs"
      provides: "xAI API validation and model fetching"
      exports: ["validate_and_fetch_models"]
    - path: "src-tauri/src/commands/permissions.rs"
      provides: "macOS Accessibility settings launcher"
      exports: ["open_accessibility_settings"]
  key_links:
    - from: "src-tauri/src/commands/xai.rs"
      to: "https://api.x.ai/v1/models"
      via: "reqwest HTTP GET with Bearer token"
      pattern: "reqwest::Client.*get.*api\\.x\\.ai"
    - from: "src-tauri/src/commands/keychain.rs"
      to: "macOS Keychain"
      via: "keyring::Entry"
      pattern: "Entry::new.*cmd-k"
    - from: "src-tauri/src/lib.rs"
      to: "all new commands"
      via: "tauri::generate_handler! macro"
      pattern: "save_api_key.*get_api_key.*validate_and_fetch_models"
---

<objective>
Build the Rust backend commands for secure API key storage (macOS Keychain via keyring crate), xAI API validation and model fetching (reqwest HTTP), and Accessibility permission settings launcher.

Purpose: Establishes the security boundary -- API key never touches the JS layer as plaintext. All Keychain and HTTP operations happen in Rust, exposed as Tauri IPC commands.
Output: Three new Rust command modules (keychain.rs, xai.rs, permissions.rs) registered in lib.rs with HTTP capabilities configured.
</objective>

<execution_context>
@/Users/lakshmanturlapati/.claude/get-shit-done/workflows/execute-plan.md
@/Users/lakshmanturlapati/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-settings-configuration/02-RESEARCH.md
@src-tauri/Cargo.toml
@src-tauri/src/lib.rs
@src-tauri/src/commands/mod.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add keyring and HTTP dependencies, create keychain.rs and xai.rs command modules</name>
  <files>
    src-tauri/Cargo.toml
    src-tauri/src/commands/keychain.rs
    src-tauri/src/commands/xai.rs
    src-tauri/src/commands/mod.rs
  </files>
  <action>
    1. Add to src-tauri/Cargo.toml [dependencies]:
       - `keyring = { version = "3", features = ["apple-native"] }` for macOS Keychain access
       - `tauri-plugin-http = "2"` for reqwest re-export (HTTP calls to xAI API)
       - `reqwest` is NOT needed separately -- use `tauri_plugin_http::reqwest` re-export

    2. Create src-tauri/src/commands/keychain.rs with three #[tauri::command] functions:
       - `save_api_key(key: String) -> Result<(), String>`: Creates `Entry::new("com.lakshmanturlapati.cmd-k", "xai_api_key")`, calls `entry.set_password(&key)`, maps errors to String
       - `get_api_key() -> Result<Option<String>, String>`: Creates same Entry, calls `entry.get_password()`. Returns `Ok(Some(key))` on success, `Ok(None)` on `keyring::Error::NoEntry`, `Err` on other errors
       - `delete_api_key() -> Result<(), String>`: Creates same Entry, calls `entry.delete_credential()`, maps errors to String
       - Use constants for SERVICE ("com.lakshmanturlapati.cmd-k") and ACCOUNT ("xai_api_key")

    3. Create src-tauri/src/commands/xai.rs:
       - Define `XaiModel` struct with `id: String` and `object: String` (derive Serialize, Deserialize, Clone)
       - Define private `ModelsResponse` struct with `data: Vec<XaiModel>` (derive Deserialize)
       - Define `XaiModelWithMeta` struct with `id: String` and `label: String` (derive Serialize, Clone) -- this is what frontend receives
       - Create `validate_and_fetch_models(api_key: String) -> Result<Vec<XaiModelWithMeta>, String>`:
         - Use `tauri_plugin_http::reqwest::Client::new()` to make GET request to "https://api.x.ai/v1/models" with `Authorization: Bearer {api_key}` header
         - On 200: parse JSON as ModelsResponse, filter out models with "image" or "video" in id, map to XaiModelWithMeta with label logic:
           - id contains "grok-3-mini" -> label "Fast"
           - id contains "grok-3" (but not mini) -> label "Balanced"
           - id contains "grok-4" -> label "Most capable"
           - else -> label "" (empty)
         - On 401: return Err("invalid_key".to_string())
         - On other status: return Err(format!("API error: {}", status))
         - On network error: return Err(format!("Network error: {}", e))
       - FALLBACK: If GET /v1/models returns 404, fall back to returning a hardcoded list: ["grok-3", "grok-3-mini", "grok-4", "grok-4-fast", "grok-code-fast-1"] and validate key with a minimal POST to /v1/chat/completions with max_tokens=1. Build the fallback from day one -- wrap in a private helper.
       - The function is async (uses reqwest async API)

    4. Update src-tauri/src/commands/mod.rs to add:
       - `pub mod keychain;`
       - `pub mod xai;`
       - `pub mod permissions;` (created in next task)
  </action>
  <verify>
    Run `cd src-tauri && cargo check` -- should compile without errors. Verify keychain.rs, xai.rs exist with correct function signatures.
  </verify>
  <done>
    keyring crate added to Cargo.toml. keychain.rs exposes save/get/delete_api_key commands. xai.rs exposes validate_and_fetch_models async command with 404 fallback. mod.rs declares all new modules.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create permissions.rs, register all commands in lib.rs, configure HTTP capabilities</name>
  <files>
    src-tauri/src/commands/permissions.rs
    src-tauri/src/lib.rs
    src-tauri/capabilities/default.json
  </files>
  <action>
    1. Create src-tauri/src/commands/permissions.rs:
       - `open_accessibility_settings()` Tauri command (no return value needed -- fire and forget):
         - Use `std::process::Command::new("open").arg("x-apple.systempreferences:com.apple.preference.security?Privacy_Accessibility").spawn().ok();`
       - `check_accessibility_permission() -> bool` Tauri command:
         - Use the macOS Accessibility API: call `AXIsProcessTrusted()` from the ApplicationServices framework
         - Add `extern "C" { fn AXIsProcessTrusted() -> bool; }` block at top of file (this is a stable public C function from ApplicationServices.framework, auto-linked on macOS)
         - Return the boolean result
         - Gate with `#[cfg(target_os = "macos")]` and provide a `#[cfg(not(target_os = "macos"))]` fallback returning false
         - This avoids adding the tauri-plugin-macos-permissions dependency for a single FFI call

    2. Update src-tauri/src/lib.rs:
       - Add new imports in the `use commands::` block:
         - `keychain::{save_api_key, get_api_key, delete_api_key}`
         - `xai::validate_and_fetch_models`
         - `permissions::{open_accessibility_settings, check_accessibility_permission}`
       - Add `.plugin(tauri_plugin_http::init())` to the builder chain (after the store plugin)
       - Add all 5 new commands to `tauri::generate_handler![]`:
         - save_api_key, get_api_key, delete_api_key, validate_and_fetch_models, open_accessibility_settings, check_accessibility_permission

    3. Update src-tauri/capabilities/default.json:
       - Add to the permissions array:
         - `"http:default"`
         - `{ "identifier": "http:default", "allow": [{ "url": "https://api.x.ai/**" }] }`
       - Add store:allow-load permission (needed for Store.load in frontend):
         - `"store:allow-load"`
       - Add store:allow-delete permission (may be needed for clearing settings):
         - `"store:allow-delete"`
  </action>
  <verify>
    Run `cd src-tauri && cargo check` -- all commands compile. Verify capabilities/default.json is valid JSON with api.x.ai domain allowed. Verify lib.rs has all 6 new commands in generate_handler.
  </verify>
  <done>
    permissions.rs provides open_accessibility_settings and check_accessibility_permission. lib.rs registers all new commands and HTTP plugin. Capabilities allow HTTP to api.x.ai and store operations. Full Rust backend ready for frontend consumption.
  </done>
</task>

</tasks>

<verification>
1. `cd src-tauri && cargo check` passes with zero errors
2. All 3 new files exist: commands/keychain.rs, commands/xai.rs, commands/permissions.rs
3. mod.rs declares keychain, xai, permissions modules
4. lib.rs invoke_handler includes all 6 new commands
5. Cargo.toml has keyring and tauri-plugin-http dependencies
6. capabilities/default.json allows https://api.x.ai/** and store operations
</verification>

<success_criteria>
- cargo check passes cleanly
- 6 new Tauri IPC commands are registered and callable from frontend
- Keychain operations use keyring crate with "com.lakshmanturlapati.cmd-k" service identifier
- HTTP calls to xAI API go through Rust (not frontend JS), keeping API key server-side
- Accessibility permission check uses native FFI, not a plugin dependency
</success_criteria>

<output>
After completion, create `.planning/phases/02-settings-configuration/02-01-SUMMARY.md`
</output>
