---
phase: 05-safety-layer
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src-tauri/src/commands/safety.rs
  - src-tauri/src/commands/mod.rs
  - src-tauri/src/lib.rs
  - src/store/index.ts
  - src/components/Settings/PreferencesTab.tsx
  - src/App.tsx
autonomous: true
requirements: [AICG-03]

must_haves:
  truths:
    - "check_destructive IPC command returns true for rm -rf, git push --force, DROP TABLE, sudo rm, and other destructive patterns"
    - "check_destructive IPC command returns false for safe commands like ls, git status, npm run dev"
    - "get_destructive_explanation IPC command returns a plain-English sentence explaining why a command is destructive"
    - "Zustand store has isDestructive, destructiveExplanation, destructiveDismissed, destructiveDetectionEnabled fields"
    - "PreferencesTab shows on/off toggle for destructive command warnings"
    - "Toggle state persists across app restarts via settings.json"
  artifacts:
    - path: "src-tauri/src/commands/safety.rs"
      provides: "Destructive pattern detection and AI explanation"
      exports: ["check_destructive", "get_destructive_explanation"]
    - path: "src/store/index.ts"
      provides: "Destructive detection state fields and actions"
      contains: "isDestructive"
    - path: "src/components/Settings/PreferencesTab.tsx"
      provides: "Toggle for destructive detection"
      contains: "Destructive command warnings"
  key_links:
    - from: "src-tauri/src/commands/safety.rs"
      to: "src-tauri/src/lib.rs"
      via: "generate_handler registration"
      pattern: "check_destructive.*get_destructive_explanation"
    - from: "src/components/Settings/PreferencesTab.tsx"
      to: "src/store/index.ts"
      via: "useOverlayStore selector"
      pattern: "destructiveDetectionEnabled"
    - from: "src/App.tsx"
      to: "settings.json"
      via: "Store.load + store.get"
      pattern: "destructiveDetectionEnabled"
---

<objective>
Create the Rust backend for destructive command detection (regex pattern matching + AI-generated explanation via xAI API) and extend the frontend state with detection toggle persistence.

Purpose: Establish the detection pipeline and user preference infrastructure that Plan 02 will wire into the badge UI and overlay integration.
Output: Two new Tauri IPC commands (check_destructive, get_destructive_explanation), extended Zustand state, settings toggle, startup preference loading.
</objective>

<execution_context>
@/Users/lakshmanturlapati/.claude/get-shit-done/workflows/execute-plan.md
@/Users/lakshmanturlapati/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-safety-layer/05-CONTEXT.md
@.planning/phases/05-safety-layer/05-RESEARCH.md
@.planning/phases/04-ai-command-generation/04-01-SUMMARY.md
@src-tauri/src/commands/ai.rs
@src-tauri/src/commands/mod.rs
@src-tauri/src/lib.rs
@src/store/index.ts
@src/components/Settings/PreferencesTab.tsx
@src/App.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create safety.rs with check_destructive and get_destructive_explanation commands</name>
  <files>
    src-tauri/src/commands/safety.rs
    src-tauri/src/commands/mod.rs
    src-tauri/src/lib.rs
  </files>
  <action>
Create `src-tauri/src/commands/safety.rs` with two Tauri IPC commands:

**1. `check_destructive(command: String) -> bool`**
- Use `once_cell::sync::Lazy` with `regex::RegexSet` for zero-allocation pattern matching
- Both `regex` and `once_cell` are already in Cargo.toml -- no new deps needed
- Comprehensive destructive pattern list (all patterns use `\b` word boundaries to avoid false positives):
  - File destruction: `rm -rf`, `rm -r`, `shred`, `unlink`, `rmdir`
  - Git force ops: `git push --force`, `git push -f`, `git reset --hard`, `git clean -f`, `git branch -D`, `git rebase --force`
  - Database mutations: `DROP TABLE`, `DROP DATABASE`, `DROP SCHEMA`, `DROP INDEX`, `TRUNCATE TABLE`, `DELETE FROM ... ;` (without WHERE), `DELETE FROM ... $` (end of string without WHERE)
  - System/permission: `sudo rm`, `chmod 777`, `mkfs`, `dd if=`, `shutdown`, `reboot`, `pkill -9`, `killall`, `fdisk`, `diskutil erase`, `format X:`, `> /dev/sd[a-z]`, `> /dev/disk[0-9]`
- Return `DESTRUCTIVE_PATTERNS.is_match(&command)`

**2. `get_destructive_explanation(command: String, on_result: tauri::ipc::Channel<String>) -> Result<(), String>`**
- Read API key from Keychain using same SERVICE/ACCOUNT constants as ai.rs: `SERVICE = "com.lakshmanturlapati.cmd-k"`, `ACCOUNT = "xai_api_key"`
- Non-streaming POST to `https://api.x.ai/v1/chat/completions` with `stream: false`
- System prompt: "You are a safety assistant. In one plain-English sentence (max 20 words), explain what the following terminal command does and why it is destructive. Be specific about what data or state it will permanently change or delete. No markdown, no code fences."
- User message: the command string
- Use the user's selected model from store if available, but default to the same model pattern -- just pass `"grok-3-mini"` with a fallback note. Actually, since we cannot read Zustand from Rust, use the model passed from frontend (add a `model: String` parameter).
- IMPORTANT: Use `tauri_plugin_http::reqwest` (not raw reqwest), `.body(json_string)` for request, `.bytes()` + `serde_json::from_slice` for response parsing (same pattern as ai.rs -- the reqwest re-export lacks `.json()` feature)
- Extract `choices[0].message.content` from response JSON
- Fallback string if extraction fails: "This command makes irreversible changes."
- Send explanation via `on_result.send(explanation)`
- Set `temperature: 0.0` for deterministic output

**Registration:**
- Add `pub mod safety;` to `src-tauri/src/commands/mod.rs`
- Add `commands::safety::{check_destructive, get_destructive_explanation}` to the use block in `src-tauri/src/lib.rs`
- Add both commands to the `generate_handler![]` macro in `src-tauri/src/lib.rs`
  </action>
  <verify>
Run `cd src-tauri && cargo check 2>&1 | grep -E "error|warning.*safety"` -- should compile with zero errors. Warnings are acceptable if they are pre-existing ObjC FFI warnings, not new ones from safety.rs.
  </verify>
  <done>
safety.rs compiles, both commands registered in generate_handler, cargo check passes with no new errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Extend Zustand store with destructive detection state, add settings toggle, load preference on startup</name>
  <files>
    src/store/index.ts
    src/components/Settings/PreferencesTab.tsx
    src/App.tsx
  </files>
  <action>
**1. Extend Zustand store (`src/store/index.ts`):**

Add 4 new state fields to `OverlayState` interface:
```typescript
isDestructive: boolean;
destructiveExplanation: string | null;
destructiveDismissed: boolean;
destructiveDetectionEnabled: boolean;
```

Add 4 new actions to `OverlayState` interface:
```typescript
setIsDestructive: (value: boolean) => void;
setDestructiveExplanation: (explanation: string | null) => void;
dismissDestructiveBadge: () => void;
setDestructiveDetectionEnabled: (enabled: boolean) => void;
```

Add initial values in the `create<OverlayState>` body:
```typescript
isDestructive: false,
destructiveExplanation: null,
destructiveDismissed: false,
destructiveDetectionEnabled: true,  // default ON
```

Add action implementations:
```typescript
setIsDestructive: (value) => set({ isDestructive: value }),
setDestructiveExplanation: (explanation) => set({ destructiveExplanation: explanation }),
dismissDestructiveBadge: () => set({ destructiveDismissed: true }),
setDestructiveDetectionEnabled: (enabled) => set({ destructiveDetectionEnabled: enabled }),
```

Add resets in `show()` setter: `isDestructive: false, destructiveExplanation: null, destructiveDismissed: false`

Add resets in `hide()` setter: `isDestructive: false, destructiveExplanation: null, destructiveDismissed: false`

Do NOT reset `destructiveDetectionEnabled` in show/hide -- it is a user preference.

**2. Add toggle to PreferencesTab (`src/components/Settings/PreferencesTab.tsx`):**

Import `useOverlayStore` from `@/store` and `Store` from `@tauri-apps/plugin-store`.

Add a new section below the "Keyboard Shortcut" section with:
- Label: "Destructive command warnings" (text-white/70 text-xs)
- Toggle button: simple rounded-full div (w-8 h-4) that changes color between `bg-red-500/60` (enabled) and `bg-white/10` (disabled)
- Add an inner circle div (w-3 h-3 rounded-full bg-white) that translates left/right based on state
- onClick handler: flip the store value AND persist to settings.json via `Store.load("settings.json")` then `store.set("destructiveDetectionEnabled", newValue)` then `store.save()`
- Use `aria-label="Toggle destructive command detection"` for accessibility

**3. Load toggle preference on startup (`src/App.tsx`):**

In the `checkOnboarding` function, after the existing `savedModel` loading line (`const savedModel = await store.get<string>("selectedModel")`), add:
```typescript
const destructiveEnabled = await store.get<boolean>("destructiveDetectionEnabled");
useOverlayStore.getState().setDestructiveDetectionEnabled(destructiveEnabled ?? true);
```

This ensures the toggle state is restored from settings.json on app startup. `undefined` (never set) defaults to `true` (warnings enabled).

Also add the same loading inside the `if (!onboardingComplete)` branch, after the onboarding check logic, so the toggle is loaded regardless of onboarding status. Place it right before the `openOnboarding(...)` calls (any of the three branches).
  </action>
  <verify>
Run `npx tsc --noEmit` from the project root -- should compile with zero TypeScript errors. Visually confirm PreferencesTab has the toggle by checking the file content.
  </verify>
  <done>
Zustand store has 4 new fields and 4 new actions. PreferencesTab renders destructive command warnings toggle. App.tsx loads the persisted toggle preference on startup. TypeScript compiles clean.
  </done>
</task>

</tasks>

<verification>
1. `cd src-tauri && cargo check` -- zero new errors
2. `npx tsc --noEmit` -- zero TypeScript errors
3. safety.rs contains `check_destructive` and `get_destructive_explanation` functions
4. mod.rs contains `pub mod safety;`
5. lib.rs generate_handler includes both safety commands
6. store/index.ts has `isDestructive`, `destructiveExplanation`, `destructiveDismissed`, `destructiveDetectionEnabled` fields
7. PreferencesTab.tsx contains toggle UI with "Destructive command warnings" label
8. App.tsx loads `destructiveDetectionEnabled` from settings.json on startup
</verification>

<success_criteria>
Both Rust safety commands compile and are registered. Zustand store extended with 4 destructive detection fields and 4 actions. Settings toggle persists preference. App loads preference on startup. All TypeScript and Rust compilation clean.
</success_criteria>

<output>
After completion, create `.planning/phases/05-safety-layer/05-01-SUMMARY.md`
</output>
