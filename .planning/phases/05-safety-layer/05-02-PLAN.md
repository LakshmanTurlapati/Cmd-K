---
phase: 05-safety-layer
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - src/components/DestructiveBadge.tsx
  - src/components/Overlay.tsx
  - src/store/index.ts
autonomous: false
requirements: [AICG-03]

must_haves:
  truths:
    - "Red 'Destructive' badge appears next to shell badge when AI generates a destructive command"
    - "Badge only appears after streaming completes (displayMode === result), never during streaming"
    - "Badge has ~200ms fade-in animation"
    - "User can click badge to dismiss it for that command"
    - "Hovering badge shows tooltip with AI-generated explanation of what the command does"
    - "Tooltip shows spinner while explanation loads, then swaps to text"
    - "Badge does not appear when destructive detection is toggled off in settings"
    - "Copy shortcut works identically for destructive and non-destructive commands (no blocking)"
    - "New query resets the destructive badge (no stale badge from previous query)"
  artifacts:
    - path: "src/components/DestructiveBadge.tsx"
      provides: "Destructive warning badge with tooltip"
      min_lines: 40
    - path: "src/components/Overlay.tsx"
      provides: "Badge placement next to shell badge"
      contains: "DestructiveBadge"
    - path: "src/store/index.ts"
      provides: "Detection trigger in submitQuery success block"
      contains: "check_destructive"
  key_links:
    - from: "src/store/index.ts"
      to: "src-tauri/src/commands/safety.rs"
      via: "invoke check_destructive"
      pattern: 'invoke.*check_destructive'
    - from: "src/components/DestructiveBadge.tsx"
      to: "src-tauri/src/commands/safety.rs"
      via: "invoke get_destructive_explanation"
      pattern: 'invoke.*get_destructive_explanation'
    - from: "src/components/Overlay.tsx"
      to: "src/components/DestructiveBadge.tsx"
      via: "conditional render in badge row"
      pattern: "DestructiveBadge"
---

<objective>
Wire destructive command detection into the streaming pipeline, create the DestructiveBadge component with Radix UI tooltip, and integrate into the Overlay badge row.

Purpose: Complete the user-visible safety layer -- the red "Destructive" badge with hover explanation that informs users about dangerous commands.
Output: Working DestructiveBadge component, detection wiring in submitQuery, Overlay badge placement.
</objective>

<execution_context>
@/Users/lakshmanturlapati/.claude/get-shit-done/workflows/execute-plan.md
@/Users/lakshmanturlapati/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-safety-layer/05-CONTEXT.md
@.planning/phases/05-safety-layer/05-RESEARCH.md
@.planning/phases/05-safety-layer/05-01-SUMMARY.md
@src/store/index.ts
@src/components/Overlay.tsx
@src-tauri/src/commands/safety.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create DestructiveBadge component, wire detection in submitQuery, integrate in Overlay</name>
  <files>
    src/components/DestructiveBadge.tsx
    src/store/index.ts
    src/components/Overlay.tsx
  </files>
  <action>
**Step 0: Verify Radix tooltip import path**

Before writing component code, verify the correct import path for Radix UI Tooltip. The project has `radix-ui` umbrella package (v1.4.3). Check if `@radix-ui/react-tooltip` resolves:
- Run: `node -e "require.resolve('@radix-ui/react-tooltip')"` in the project root
- If it resolves, use `import * as Tooltip from "@radix-ui/react-tooltip"`
- If it fails, install: `npm install @radix-ui/react-tooltip` (single small package)

**Step 1: Create `src/components/DestructiveBadge.tsx`**

```tsx
import * as Tooltip from "@radix-ui/react-tooltip";  // or correct path from Step 0
import { invoke, Channel } from "@tauri-apps/api/core";
import { useOverlayStore } from "@/store";
import { useEffect, useState } from "react";
```

Component `DestructiveBadge`:
- Read from store: `streamingText`, `destructiveExplanation`, `dismissDestructiveBadge`, `setDestructiveExplanation`, `selectedModel`
- Local state: `visible` (boolean, starts false for fade-in)
- useEffect on mount: `setTimeout(() => setVisible(true), 0)` for fade-in trigger
- useEffect on mount (eager explanation loading):
  - Create `new Channel<string>()`
  - Set `ch.onmessage = (explanation) => setDestructiveExplanation(explanation)`
  - Call `invoke("get_destructive_explanation", { command: streamingText, model: selectedModel ?? "grok-3-mini", onResult: ch })`
  - Catch: set fallback explanation "This command makes irreversible changes."
  - Empty deps array (fire once on mount)
- Render: `Tooltip.Provider` (delayDuration=200) wrapping `Tooltip.Root` wrapping:
  - `Tooltip.Trigger` (asChild): `<span>` with classes:
    - `text-[11px] font-mono px-1.5 py-0.5 rounded bg-red-500/20 text-red-400 border border-red-500/30 cursor-pointer transition-opacity duration-200`
    - Conditional: `opacity-100` when visible, `opacity-0` when not
    - onClick: `dismissDestructiveBadge`
    - Text content: "Destructive"
  - `Tooltip.Portal` > `Tooltip.Content` (side="top", sideOffset=4):
    - Classes: `max-w-[220px] text-[11px] text-white/80 bg-black/80 border border-white/10 rounded px-2 py-1.5 font-sans shadow-lg z-50`
    - Content: if `destructiveExplanation` is not null, show the text; else show spinner (`<span className="inline-block w-3 h-3 border border-white/30 border-t-white/70 rounded-full animate-spin" />`)
    - Include `<Tooltip.Arrow className="fill-black/80" />`

**Step 2: Wire detection in `submitQuery` (`src/store/index.ts`)**

In the `submitQuery` action, at the START of the function (when transitioning to streaming state), add resets:
```typescript
isDestructive: false,
destructiveExplanation: null,
destructiveDismissed: false,
```
Add these to the existing `set({...})` call that transitions to streaming state (the one with `isStreaming: true, displayMode: "streaming"`).

In the `submitQuery` success block, AFTER `set({ isStreaming: false, displayMode: "result", turnHistory: trimmedHistory })` and AFTER the auto-copy block, add detection:
```typescript
// Check for destructive command
const detectionState = useOverlayStore.getState();
if (detectionState.destructiveDetectionEnabled && finalText) {
  invoke<boolean>("check_destructive", { command: finalText })
    .then((isDestructive) => {
      if (isDestructive) {
        useOverlayStore.getState().setIsDestructive(true);
        // Explanation is loaded eagerly by DestructiveBadge on mount
      }
    })
    .catch(console.error);
}
```

**Step 3: Integrate DestructiveBadge in Overlay.tsx (`src/components/Overlay.tsx`)**

Import `DestructiveBadge` from `./DestructiveBadge`.
Add three new store selectors:
```typescript
const isDestructive = useOverlayStore((s) => s.isDestructive);
const destructiveDismissed = useOverlayStore((s) => s.destructiveDismissed);
```

In the badge row (the `<div className="flex items-center gap-2 min-h-[20px]">` section), after the existing shell badge `<span>`, add:
```tsx
{!destructiveDismissed && isDestructive && displayMode === "result" && (
  <DestructiveBadge />
)}
```

This renders the badge only when: not dismissed AND is destructive AND streaming is complete (result mode).
  </action>
  <verify>
Run `npx tsc --noEmit` -- zero TypeScript errors. Verify DestructiveBadge.tsx exists and imports Tooltip correctly. Verify Overlay.tsx imports and conditionally renders DestructiveBadge. Verify submitQuery in store/index.ts calls invoke("check_destructive").
  </verify>
  <done>
DestructiveBadge component renders red badge with Radix tooltip (spinner while loading, explanation text when ready). Detection fires after streaming completes in submitQuery. Badge appears in Overlay badge row next to shell badge only in result mode. Destructive state resets on new query submission.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 2: Human verification of complete safety layer</name>
  <files>none (verification only)</files>
  <action>
Human verification of the complete destructive command detection and warning badge system:
- Rust backend: regex pattern matching for 25+ destructive patterns, AI-generated explanations via xAI
- Red "Destructive" badge in overlay results header, next to shell badge
- Tooltip with AI explanation on hover (spinner while loading)
- Badge dismissable by clicking
- On/off toggle in Settings > Preferences
- Toggle persists across app restarts

Verification steps:

**Prerequisites:** App must be running (`npm run tauri dev`). API key must be configured.

**Test 1: Destructive command detection**
1. Open overlay (Cmd+K or configured hotkey)
2. Type: "delete all files in the current directory recursively"
3. Press Enter and wait for streaming to complete
4. Verify: Red "Destructive" badge appears with ~200ms fade-in next to the shell badge
5. Hover over the badge -- verify tooltip appears with a plain-English explanation
6. Verify: Copy still works normally (Cmd+C or click-to-copy)

**Test 2: Non-destructive command**
1. Open overlay (Cmd+K)
2. Type: "list all files in this directory"
3. Press Enter and wait for result
4. Verify: No "Destructive" badge appears

**Test 3: Badge dismiss**
1. Trigger a destructive command (e.g., "force push to main branch")
2. When badge appears, click on it
3. Verify: Badge disappears
4. Open overlay again -- verify badge state is clean (no leftover)

**Test 4: Settings toggle**
1. Type "/settings" in overlay and press Enter
2. Navigate to Preferences tab
3. Find "Destructive command warnings" toggle
4. Toggle it OFF
5. Close settings, type a destructive query ("remove all docker containers forcefully")
6. Verify: No badge appears even though command is destructive
7. Go back to settings, toggle ON
8. Repeat destructive query -- badge should appear again

**Test 5: Persistence**
1. Toggle destructive detection OFF in settings
2. Quit and restart the app
3. Open Settings > Preferences
4. Verify: Toggle is still OFF (persisted)

**Test 6: Stale badge prevention**
1. Submit a destructive command (badge appears)
2. Press Escape to return to input
3. Type a safe command (e.g., "what is the current time")
4. Press Enter
5. Verify: Previous destructive badge is gone, no badge on safe result
  </action>
  <verify>All 6 test scenarios pass visual and functional verification.</verify>
  <done>Human confirms: destructive badge appears for dangerous commands, tooltip shows explanation, dismiss works, settings toggle works, persistence works, stale badge prevention works.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` -- zero TypeScript errors
2. DestructiveBadge.tsx renders red badge with Radix tooltip
3. Overlay.tsx conditionally renders DestructiveBadge in badge row
4. submitQuery calls check_destructive after streaming completes
5. Destructive state resets at start of each new query
6. Badge only appears when displayMode === "result" (not during streaming)
7. Human verification confirms all 6 test scenarios pass
</verification>

<success_criteria>
Destructive commands trigger a visible red "Destructive" badge with AI-generated explanation tooltip. Badge is dismissable, non-blocking (copy works normally), and respects the settings toggle. Detection state resets cleanly between queries. Human verification confirms end-to-end flow works.
</success_criteria>

<output>
After completion, create `.planning/phases/05-safety-layer/05-02-SUMMARY.md`
</output>
