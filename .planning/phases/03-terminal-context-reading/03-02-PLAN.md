---
phase: 03-terminal-context-reading
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - src-tauri/src/terminal/ax_reader.rs
  - src-tauri/src/terminal/filter.rs
  - src-tauri/src/terminal/mod.rs
autonomous: true
requirements: [TERM-03, TERM-04]

must_haves:
  truths:
    - "Terminal.app visible text is read via AXUIElement kAXValueAttribute on AXTextArea"
    - "iTerm2 active pane text is read via kAXFocusedUIElementAttribute then kAXValueAttribute"
    - "GPU-rendered terminals (Alacritty, kitty, WezTerm) silently skip AX text read and return None for visible_output"
    - "API keys, tokens, passwords are filtered from captured text before inclusion in TerminalContext"
    - "Detection completes within 500ms hard timeout -- overlay never stalls"
    - "Per-element AX messaging timeout set to 1 second to prevent hangs on unresponsive terminals"
    - "AX error codes from GPU terminals are treated as silent fallback triggers, not user-facing errors"
  artifacts:
    - path: "src-tauri/src/terminal/ax_reader.rs"
      provides: "AX tree walk for Terminal.app and iTerm2 text reading"
      contains: "AXUIElementCreateApplication"
    - path: "src-tauri/src/terminal/filter.rs"
      provides: "Sensitive data regex filtering for terminal output"
      contains: "SENSITIVE_PATTERNS"
  key_links:
    - from: "src-tauri/src/terminal/mod.rs"
      to: "src-tauri/src/terminal/ax_reader.rs"
      via: "detect() calls ax_reader::read_terminal_text() for non-GPU terminals"
      pattern: "ax_reader::read_terminal_text"
    - from: "src-tauri/src/terminal/mod.rs"
      to: "src-tauri/src/terminal/filter.rs"
      via: "detect() applies filter::filter_sensitive() to AX text before returning"
      pattern: "filter::filter_sensitive"
    - from: "src-tauri/src/terminal/ax_reader.rs"
      to: "accessibility_sys"
      via: "AXUIElementCreateApplication, AXUIElementCopyAttributeValue, kAXValueAttribute"
      pattern: "accessibility_sys::"
---

<objective>
AX tree text reading for Terminal.app and iTerm2, sensitive data filtering, and hard timeout wrapper for the detection pipeline.

Purpose: Complete the terminal context reading pipeline by adding visible output capture (the highest-value signal for AI command generation). Terminal.app and iTerm2 expose text through the macOS Accessibility tree; GPU-rendered terminals silently fall back to process-only context. All captured text is filtered for secrets before inclusion.

Output: `ax_reader.rs` (AX tree walk), `filter.rs` (regex-based secret filtering), updated `mod.rs` (timeout wrapper + full pipeline wiring).
</objective>

<execution_context>
@/Users/lakshmanturlapati/.claude/get-shit-done/workflows/execute-plan.md
@/Users/lakshmanturlapati/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-terminal-context-reading/03-RESEARCH.md
@.planning/phases/03-terminal-context-reading/03-01-SUMMARY.md

Key files from Plan 01:
@src-tauri/src/terminal/mod.rs (TerminalContext struct, detect() function to update)
@src-tauri/src/terminal/detect.rs (is_gpu_terminal() used to skip AX read)
@src-tauri/src/terminal/process.rs (ProcessInfo already provides CWD + shell + running process)
@src-tauri/src/commands/terminal.rs (get_terminal_context calls detect)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement AX tree text reader for Terminal.app and iTerm2</name>
  <files>
    src-tauri/src/terminal/ax_reader.rs
    src-tauri/src/terminal/mod.rs
  </files>
  <action>
    **terminal/ax_reader.rs:** Create the Accessibility tree walker that reads visible terminal text.

    Use `accessibility-sys` crate for FFI bindings. The AX tree structure:
    - Terminal.app: AXApplication -> AXFocusedWindow -> AXScrollArea -> AXTextArea -> kAXValueAttribute
    - iTerm2: AXApplication -> kAXFocusedUIElementAttribute (returns active text area directly) -> kAXValueAttribute

    Implementation:
    ```rust
    #[cfg(target_os = "macos")]
    use accessibility_sys::{
        AXUIElementCreateApplication,
        AXUIElementCopyAttributeValue,
        AXUIElementSetMessagingTimeout,
    };
    use core_foundation::{
        base::{CFRelease, TCFType, CFTypeRef},
        string::CFString,
        array::CFArray,
    };
    ```

    Key functions:

    1. `pub fn read_terminal_text(app_pid: i32, bundle_id: &str) -> Option<String>`
       - Creates AXApplication element from PID
       - Sets messaging timeout to 1.0 seconds per element (Pitfall 4)
       - For iTerm2 (`com.googlecode.iterm2`): use `kAXFocusedUIElementAttribute` on the app to get the active text area directly, then read `kAXValueAttribute`
       - For Terminal.app (`com.apple.Terminal`): get focused window -> walk children for AXScrollArea -> find AXTextArea child -> read `kAXValueAttribute`
       - Returns the text content as a String

    2. Helper: `unsafe fn get_ax_attribute(element: CFTypeRef, attribute: &str) -> Option<CFTypeRef>`
       - Wraps AXUIElementCopyAttributeValue with proper CFString conversion
       - Returns None on any AX error code (silent fallback per Pitfall 5 -- kAXErrorCannotComplete, kAXErrorNotImplemented)

    3. Helper: `unsafe fn get_ax_string_value(element: CFTypeRef) -> Option<String>`
       - Gets kAXValueAttribute and converts CFString to Rust String

    4. Helper: `unsafe fn get_ax_role(element: CFTypeRef) -> Option<String>`
       - Gets kAXRoleAttribute to identify AXScrollArea, AXTextArea roles

    5. Helper: `unsafe fn find_text_area_in_children(element: CFTypeRef) -> Option<CFTypeRef>`
       - Gets kAXChildrenAttribute (CFArray of AXUIElements)
       - Iterates children looking for AXScrollArea or AXTextArea role
       - Recursively walks into AXScrollArea to find AXTextArea
       - Max recursion depth of 5 to prevent runaway walks

    IMPORTANT safety notes:
    - All AXUIElement refs must be CFReleased when done (use scope guards or manual release)
    - Do NOT serialize AXUIElementRef -- it is not Send+Sync. Convert to String before returning.
    - Handle all AX error codes gracefully -- return None, never panic
    - kAXErrorCannotComplete (Alacritty Sequoia issue, Pitfall 5) should be a silent None return
    - The accessibility-sys crate provides `kAXErrorSuccess` (0) constant -- any non-zero is a failure

    **terminal/mod.rs:** Add `pub mod ax_reader;` to module declarations. Do NOT wire it into detect() yet -- that happens in Task 2 after the filter is ready.
  </action>
  <verify>
    Run `cd src-tauri && cargo check` -- must compile with zero errors.
    Verify `accessibility_sys` is imported: `grep "accessibility_sys" src-tauri/src/terminal/ax_reader.rs`.
    Verify AXUIElementSetMessagingTimeout is called: `grep "SetMessagingTimeout\|messaging_timeout" src-tauri/src/terminal/ax_reader.rs`.
    Verify iTerm2-specific path exists: `grep -i "iterm\|focused.*element" src-tauri/src/terminal/ax_reader.rs`.
  </verify>
  <done>
    ax_reader.rs reads visible terminal text from Terminal.app (window -> scroll area -> text area -> value) and iTerm2 (focused element -> value). Per-element AX timeout set to 1 second. All AX errors handled as silent None returns. `cargo check` passes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add sensitive data filter, timeout wrapper, and wire full detection pipeline</name>
  <files>
    src-tauri/src/terminal/filter.rs
    src-tauri/src/terminal/mod.rs
  </files>
  <action>
    **terminal/filter.rs:** Regex-based sensitive data filtering.
    ```rust
    use once_cell::sync::Lazy;
    use regex::Regex;

    static SENSITIVE_PATTERNS: Lazy<Vec<Regex>> = Lazy::new(|| {
        vec![
            // AWS Access Key
            Regex::new(r"AKIA[0-9A-Z]{16}").unwrap(),
            // Generic API key / token / password / secret patterns
            Regex::new(r#"(?i)(api[_-]?key|token|password|secret|bearer)\s*[=:]\s*['"]?[a-zA-Z0-9+/]{16,}['"]?"#).unwrap(),
            // xAI style tokens
            Regex::new(r"xai-[a-zA-Z0-9]{32,}").unwrap(),
            // OpenAI style tokens
            Regex::new(r"sk-[a-zA-Z0-9]{32,}").unwrap(),
            // GitHub tokens
            Regex::new(r"gh[pousr]_[A-Za-z0-9_]{36,}").unwrap(),
            // Private keys
            Regex::new(r"-----BEGIN [A-Z]+ PRIVATE KEY-----").unwrap(),
            // Generic high-entropy hex secrets (e.g., export SECRET=abc123...)
            Regex::new(r#"(?i)export\s+\w*(secret|key|token|password)\w*\s*=\s*\S{16,}"#).unwrap(),
        ]
    });

    /// Filter sensitive data from terminal output text.
    /// Replaces matches with [REDACTED] to prevent accidental AI exposure.
    pub fn filter_sensitive(text: &str) -> String {
        let mut result = text.to_string();
        for pattern in SENSITIVE_PATTERNS.iter() {
            result = pattern.replace_all(&result, "[REDACTED]").into_owned();
        }
        result
    }
    ```

    **terminal/mod.rs:** Update to wire the full detection pipeline with timeout:

    1. Add `pub mod filter;` to module declarations (ax_reader was added in Task 1).

    2. Update the `detect()` function to:
       - Use `detect::is_gpu_terminal(&bundle_id)` to decide whether to read AX text
       - For non-GPU terminals: call `ax_reader::read_terminal_text(previous_app_pid, &bundle_id)`
       - Apply `filter::filter_sensitive()` to any captured text
       - Set `visible_output` on TerminalContext

    3. Add a `detect_with_timeout()` wrapper function:
       ```rust
       use std::sync::mpsc;
       use std::time::Duration;

       /// Detection with hard timeout. Overlay never stalls.
       /// Uses 500ms timeout -- per-element AX timeout (1s) is the inner guard,
       /// this outer timeout ensures the whole pipeline completes quickly.
       pub fn detect_with_timeout(previous_app_pid: i32) -> Option<TerminalContext> {
           let (tx, rx) = mpsc::channel();
           std::thread::spawn(move || {
               let result = detect(previous_app_pid);
               let _ = tx.send(result);
           });
           rx.recv_timeout(Duration::from_millis(500)).ok().flatten()
       }
       ```

    4. Update `commands/terminal.rs` to call `detect_with_timeout()` instead of `detect()` directly.
       (If the file ownership rule prevents editing commands/terminal.rs in this plan, the change is just replacing `terminal::detect(pid)` with `terminal::detect_with_timeout(pid)` -- a one-line change. Since commands/terminal.rs is listed in Plan 01's files_modified, technically this plan should NOT modify it. Instead, expose `detect_with_timeout` as the public API and note that the command should call it. If the executor can make this small change as part of wiring, do so. Otherwise, leave a comment in mod.rs that commands/terminal.rs should call detect_with_timeout.)

    Actually, to keep file ownership clean: update `terminal/mod.rs` to make `detect_with_timeout` the primary public function, and rename the inner function to `detect_inner` (private). Then the existing `commands/terminal.rs` call to `terminal::detect(pid)` will route through the timeout wrapper automatically if we keep the function name `detect` but make it call the timeout version internally:

    ```rust
    /// Public API: detect with timeout (500ms). Called by get_terminal_context command.
    pub fn detect(previous_app_pid: i32) -> Option<TerminalContext> {
        let (tx, rx) = mpsc::channel();
        std::thread::spawn(move || {
            let result = detect_inner(previous_app_pid);
            let _ = tx.send(result);
        });
        rx.recv_timeout(Duration::from_millis(500)).ok().flatten()
    }

    /// Inner detection logic (runs on background thread).
    fn detect_inner(previous_app_pid: i32) -> Option<TerminalContext> {
        let bundle_id = detect::get_bundle_id(previous_app_pid)?;
        if !detect::is_known_terminal(&bundle_id) {
            return None;
        }

        let is_gpu = detect::is_gpu_terminal(&bundle_id);
        let proc_info = process::get_foreground_info(previous_app_pid);

        // Read visible output for AX-capable terminals only
        let visible_output = if !is_gpu {
            ax_reader::read_terminal_text(previous_app_pid, &bundle_id)
                .map(|text| filter::filter_sensitive(&text))
        } else {
            None // GPU terminals: silent fallback, no text
        };

        Some(TerminalContext {
            shell_type: proc_info.shell_type,
            cwd: proc_info.cwd,
            visible_output,
            running_process: proc_info.running_process,
        })
    }
    ```

    This approach does NOT modify commands/terminal.rs (it already calls `terminal::detect(pid)` from Plan 01). The timeout wrapping is transparent.
  </action>
  <verify>
    Run `cd src-tauri && cargo check` -- must compile with zero errors.
    Run `cd src-tauri && cargo clippy -- -W clippy::all` -- no errors.
    Verify filter patterns exist: `grep "SENSITIVE_PATTERNS\|REDACTED" src-tauri/src/terminal/filter.rs`.
    Verify timeout wrapper: `grep "recv_timeout\|500" src-tauri/src/terminal/mod.rs`.
    Verify AX text is wired into detect: `grep "ax_reader::read_terminal_text" src-tauri/src/terminal/mod.rs`.
    Verify GPU terminals skip AX read: `grep "is_gpu_terminal" src-tauri/src/terminal/mod.rs`.
    Verify filter applied to output: `grep "filter_sensitive" src-tauri/src/terminal/mod.rs`.
  </verify>
  <done>
    filter.rs has 7 sensitive data regex patterns compiled via once_cell::Lazy. detect() wraps detection in a 500ms timeout thread. AX text is read for Terminal.app and iTerm2, skipped for GPU terminals. Captured text is filtered through filter_sensitive() before inclusion. `cargo check` and `cargo clippy` pass.
  </done>
</task>

</tasks>

<verification>
1. `cargo check` passes with ax_reader.rs and filter.rs
2. `cargo clippy` reports no errors
3. Terminal.app AX path: focused window -> scroll area -> text area -> value attribute
4. iTerm2 AX path: focused UI element -> value attribute
5. GPU terminals (Alacritty, kitty, WezTerm) return None for visible_output without error
6. Sensitive data patterns match AWS keys, xAI/OpenAI tokens, GitHub tokens, private keys, generic secrets
7. 500ms hard timeout on detection thread prevents overlay stalling
8. Per-element AX messaging timeout is 1 second
</verification>

<success_criteria>
- AX text reading works for Terminal.app and iTerm2 via accessibility-sys
- GPU-rendered terminals gracefully return None for visible_output
- Sensitive data (API keys, tokens, passwords) is redacted from captured output
- Detection pipeline has a 500ms hard timeout
- Full TerminalContext now includes visible_output for AX-capable terminals
- No compilation errors or clippy errors
</success_criteria>

<output>
After completion, create `.planning/phases/03-terminal-context-reading/03-02-SUMMARY.md`
</output>
