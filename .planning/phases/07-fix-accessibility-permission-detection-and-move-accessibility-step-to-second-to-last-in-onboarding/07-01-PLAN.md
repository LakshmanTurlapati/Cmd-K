---
phase: 07-fix-accessibility-permission-detection-and-move-accessibility-step-to-second-to-last-in-onboarding
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src-tauri/src/commands/permissions.rs
  - src/components/Onboarding/OnboardingWizard.tsx
  - src/App.tsx
autonomous: true
requirements: [SETT-04]

must_haves:
  truths:
    - "check_accessibility_permission returns true when AX access is actually granted, even on unsigned production builds where AXIsProcessTrusted lies"
    - "Onboarding step order is API Key -> Model -> Accessibility -> Done"
    - "Resuming onboarding with existing API key skips past API Key step correctly (effectiveStep advances to step 1)"
  artifacts:
    - path: "src-tauri/src/commands/permissions.rs"
      provides: "Dual-check AX probe fallback in check_accessibility_permission"
      contains: "ax_probe_self"
    - path: "src/components/Onboarding/OnboardingWizard.tsx"
      provides: "Reordered step labels and step-to-component mapping"
      contains: "API Key"
    - path: "src/App.tsx"
      provides: "Updated effectiveStep logic for new step order"
      contains: "onboardingStep <= 0"
  key_links:
    - from: "src-tauri/src/commands/permissions.rs"
      to: "all frontend invoke('check_accessibility_permission') call sites"
      via: "Tauri IPC (in-place function replacement, no call site changes)"
      pattern: "check_accessibility_permission"
    - from: "src/App.tsx"
      to: "src/components/Onboarding/OnboardingWizard.tsx"
      via: "openOnboarding(effectiveStep) with corrected index"
      pattern: "effectiveStep"
---

<objective>
Add AX probe fallback to Rust permission check and reorder onboarding steps so Accessibility is second-to-last.

Purpose: AXIsProcessTrusted returns false on unsigned production builds even when permission is granted (TCC identity mismatch). The fallback AX probe empirically tests actual AX API access. Onboarding reorder places API Key and Model before Accessibility so users configure their API key first.

Output: Updated permissions.rs with dual-check, reordered OnboardingWizard.tsx, fixed effectiveStep in App.tsx.
</objective>

<execution_context>
@/Users/lakshmanturlapati/.claude/get-shit-done/workflows/execute-plan.md
@/Users/lakshmanturlapati/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-fix-accessibility-permission-detection-and-move-accessibility-step-to-second-to-last-in-onboarding/07-CONTEXT.md
@.planning/phases/07-fix-accessibility-permission-detection-and-move-accessibility-step-to-second-to-last-in-onboarding/07-RESEARCH.md
@src-tauri/src/commands/permissions.rs
@src/components/Onboarding/OnboardingWizard.tsx
@src/App.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add AX probe fallback to check_accessibility_permission in Rust</name>
  <files>src-tauri/src/commands/permissions.rs</files>
  <action>
Add a private function `ax_probe_self() -> bool` to permissions.rs (macOS only, cfg-gated). This function:

1. Gets own PID via `std::process::id() as i32`
2. Creates an AX application element via `AXUIElementCreateApplication(pid)` (extern "C" declaration)
3. Creates a CFString for "AXRole" using `core_foundation_sys::string::CFStringCreateWithCString` (already a dependency in Cargo.toml)
4. Calls `AXUIElementCopyAttributeValue(app_elem, attr_cf, &mut value)` (extern "C" declaration)
5. Cleans up: CFRelease value (if non-null), CFRelease attr_cf, CFRelease app_elem
6. Returns false ONLY if error code is -25211 (kAXErrorNotTrusted). All other error codes (including -25205 kAXErrorAttributeUnsupported, -25204 kAXErrorNoValue, -25212 kAXErrorCannotComplete, and 0 kAXErrorSuccess) mean permission IS granted -- return true.

The extern "C" block declares:
- `fn AXUIElementCreateApplication(pid: i32) -> *const c_void;`
- `fn AXUIElementCopyAttributeValue(element: *const c_void, attribute: *const c_void, value: *mut *const c_void) -> i32;`
- `fn CFRelease(cf: *const c_void);`

Update the existing `check_accessibility_permission()` function (macOS cfg):
- Call `unsafe { accessibility_sys::AXIsProcessTrusted() }` first -- if true, return true immediately
- If false, call `ax_probe_self()` and return its result
- Keep the eprintln! debug log, updating it to show both check results

The `request_accessibility_permission(prompt: bool)` function remains UNCHANGED (it is only used for prompting during onboarding).

The non-macOS stub `check_accessibility_permission()` remains as-is (returns false).

Use `std::ffi::c_void` (not `core::ffi::c_void`). Use `core_foundation_sys::string::{CFStringCreateWithCString, kCFStringEncodingUTF8}` and `core_foundation_sys::base::kCFAllocatorDefault` for string creation (already imported in the file's request_accessibility_permission function).

Do NOT use `core_foundation_sys::base::CFRelease` -- declare it in the extern "C" block alongside the AX functions (avoids potential type mismatch with inline c_void).
  </action>
  <verify>
Run `cd src-tauri && cargo check` -- must compile without errors. Verify the function signature is unchanged: `pub fn check_accessibility_permission() -> bool`. Verify `ax_probe_self` is defined with `#[cfg(target_os = "macos")]`.
  </verify>
  <done>
check_accessibility_permission first tries AXIsProcessTrusted, then falls back to AX probe on own PID. Returns true if EITHER check confirms access. Only returns false when AX probe gets kAXErrorNotTrusted (-25211). All existing frontend call sites (store/index.ts, Overlay.tsx, App.tsx) get the fix automatically with zero changes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Reorder onboarding steps and fix effectiveStep logic</name>
  <files>src/components/Onboarding/OnboardingWizard.tsx, src/App.tsx</files>
  <action>
**OnboardingWizard.tsx changes:**

1. Update `stepLabels` array from `["Accessibility", "API Key", "Model", "Done"]` to `["API Key", "Model", "Accessibility", "Done"]`

2. Update the step content rendering (lines 115-118) from:
   ```
   {onboardingStep === 0 && <StepAccessibility onNext={handleNext} />}
   {onboardingStep === 1 && <StepApiKey onNext={handleNext} />}
   {onboardingStep === 2 && <StepModelSelect onNext={handleNext} />}
   {onboardingStep === 3 && <StepDone onComplete={handleComplete} />}
   ```
   to:
   ```
   {onboardingStep === 0 && <StepApiKey onNext={handleNext} />}
   {onboardingStep === 1 && <StepModelSelect onNext={handleNext} />}
   {onboardingStep === 2 && <StepAccessibility onNext={handleNext} />}
   {onboardingStep === 3 && <StepDone onComplete={handleComplete} />}
   ```

3. The "Skip this step" link condition (`onboardingStep < 3`) remains correct -- steps 0, 1, 2 all can be skipped. No change needed.

**App.tsx effectiveStep change (lines 78-81):**

Update the effectiveStep calculation from:
```typescript
const effectiveStep =
  onboardingStep <= 1
    ? Math.max(onboardingStep, 1)
    : onboardingStep;
```
to:
```typescript
const effectiveStep =
  onboardingStep <= 0
    ? 1  // skip past API key step since key exists
    : onboardingStep;
```

This is correct because: API Key is now step 0. If the user has an existing API key and was at step 0, we advance them to step 1 (Model). If they were at step 1+ already, keep their position. The old logic checked `<= 1` because API Key was step 1; now it checks `<= 0`.
  </action>
  <verify>
Run `cd src-tauri && cargo tauri build --debug 2>&1 | tail -5` or `npm run build` to verify frontend compiles. Manually verify in OnboardingWizard.tsx that stepLabels[0] is "API Key" and the onboardingStep===0 renders StepApiKey. Verify in App.tsx that effectiveStep checks `onboardingStep <= 0`.
  </verify>
  <done>
Onboarding wizard shows steps in order: API Key -> Model -> Accessibility -> Done. Stepper labels match step content. Users who resume onboarding with an existing API key are correctly advanced past step 0 to step 1 (Model). The TOTAL_STEPS constant (4) is unchanged. The skip link works for all non-Done steps.
  </done>
</task>

</tasks>

<verification>
1. `cd src-tauri && cargo check` passes (Rust compiles)
2. `npm run build` or equivalent frontend build passes
3. In permissions.rs: `check_accessibility_permission` calls `ax_probe_self()` when AXIsProcessTrusted returns false
4. In OnboardingWizard.tsx: stepLabels is `["API Key", "Model", "Accessibility", "Done"]` and step 0 renders StepApiKey
5. In App.tsx: effectiveStep logic uses `onboardingStep <= 0` (not `<= 1`)
</verification>

<success_criteria>
- Rust dual-check compiles and uses AX probe fallback for unsigned builds
- Onboarding step order is API Key -> Model -> Accessibility -> Done
- Resume-from-step logic handles existing API key correctly with new step indices
</success_criteria>

<output>
After completion, create `.planning/phases/07-fix-accessibility-permission-detection-and-move-accessibility-step-to-second-to-last-in-onboarding/07-01-SUMMARY.md`
</output>
