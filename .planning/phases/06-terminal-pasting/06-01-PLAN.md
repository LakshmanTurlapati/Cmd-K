---
phase: 06-terminal-pasting
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src-tauri/src/commands/paste.rs
  - src-tauri/src/commands/mod.rs
  - src-tauri/src/lib.rs
  - src/store/index.ts
  - src/components/Settings/PreferencesTab.tsx
  - src/App.tsx
autonomous: true
requirements: [TERM-01]

must_haves:
  truths:
    - "paste_to_terminal Tauri IPC command exists and can be invoked from the frontend"
    - "iTerm2 AppleScript uses write text with newline NO to place text without executing"
    - "Terminal.app AppleScript uses Control+U then keystroke to clear and type text without executing"
    - "Unsupported terminals return an error from paste_to_terminal (clipboard fallback is implicit)"
    - "autoPasteEnabled boolean exists in Zustand store and defaults to true"
    - "Settings Preferences tab has an auto-paste toggle with inline warning when disabled"
    - "autoPasteEnabled is loaded from settings.json on app startup"
  artifacts:
    - path: "src-tauri/src/commands/paste.rs"
      provides: "paste_to_terminal Tauri command with AppleScript dispatch"
      contains: "paste_to_terminal"
    - path: "src/store/index.ts"
      provides: "autoPasteEnabled state field and setAutoPasteEnabled action"
      contains: "autoPasteEnabled"
    - path: "src/components/Settings/PreferencesTab.tsx"
      provides: "Auto-paste toggle UI with warning label"
      contains: "autoPasteEnabled"
    - path: "src/App.tsx"
      provides: "Startup autoPasteEnabled load from settings.json"
      contains: "autoPasteEnabled"
  key_links:
    - from: "src-tauri/src/commands/paste.rs"
      to: "src-tauri/src/terminal/detect.rs"
      via: "get_bundle_id(pid) call to resolve terminal type"
      pattern: "detect::get_bundle_id"
    - from: "src-tauri/src/commands/paste.rs"
      to: "src-tauri/src/state.rs"
      via: "AppState.previous_app_pid read for target terminal PID"
      pattern: "previous_app_pid"
    - from: "src-tauri/src/lib.rs"
      to: "src-tauri/src/commands/paste.rs"
      via: "paste_to_terminal registered in generate_handler"
      pattern: "paste_to_terminal"
---

<objective>
Create the Rust paste_to_terminal IPC command and the frontend autoPasteEnabled settings infrastructure.

Purpose: Establish the backend paste mechanism (AppleScript dispatch via osascript) and the frontend preference toggle so that Plan 02 can wire the paste trigger into the submitQuery completion path.
Output: Working paste_to_terminal command callable from JS, autoPasteEnabled state in Zustand with settings persistence and UI toggle.
</objective>

<execution_context>
@/Users/lakshmanturlapati/.claude/get-shit-done/workflows/execute-plan.md
@/Users/lakshmanturlapati/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-terminal-pasting/06-RESEARCH.md
@src-tauri/src/commands/mod.rs
@src-tauri/src/lib.rs
@src-tauri/src/state.rs
@src-tauri/src/terminal/detect.rs
@src/store/index.ts
@src/components/Settings/PreferencesTab.tsx
@src/App.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create paste_to_terminal Rust command with AppleScript dispatch</name>
  <files>
    src-tauri/src/commands/paste.rs
    src-tauri/src/commands/mod.rs
    src-tauri/src/lib.rs
  </files>
  <action>
Create `src-tauri/src/commands/paste.rs` with a `#[tauri::command]` function `paste_to_terminal` that accepts `app: tauri::AppHandle` and `command: String` parameters, returning `Result<(), String>`.

Implementation steps:
1. Read `previous_app_pid` from `AppState` (same pattern as `commands/terminal.rs` lines 25-31): lock mutex, extract `Option<i32>`, error if None.
2. Call `crate::terminal::detect::get_bundle_id(pid)` to resolve the bundle ID. Error if None with "could not resolve bundle ID".
3. Call a helper function `build_paste_script(bundle_id: &str, command: &str) -> Result<String, String>` that:
   - Escapes `\` as `\\` and `"` as `\"` in the command string for safe AppleScript interpolation.
   - Matches on bundle_id:
     - `"com.googlecode.iterm2"` -> iTerm2 AppleScript: `tell application "iTerm2" / activate / tell current window / tell current session / write text "{escaped}" newline NO / end tell / end tell / end tell`
     - `"com.apple.Terminal"` -> Terminal.app AppleScript: `tell application "Terminal" / activate / tell application "System Events" / tell process "Terminal" / keystroke "u" using control down / keystroke "{escaped}" / end tell / end tell / end tell`
     - Any other bundle_id -> return `Err(format!("unsupported terminal: {}", bundle_id))`
4. Execute the script: `std::process::Command::new("osascript").arg("-e").arg(&script).output()`. Map spawn errors. Check `output.status.success()` and return stderr as error on failure.

Register the command:
- Add `pub mod paste;` to `src-tauri/src/commands/mod.rs`.
- Add `paste_to_terminal` to the `generate_handler![]` macro in `src-tauri/src/lib.rs` (add `use commands::paste::paste_to_terminal;` at the import block, then add `paste_to_terminal,` after `get_destructive_explanation,` in the handler list).

Do NOT:
- Use `do script` for Terminal.app (it executes the command immediately).
- Install any new crates -- `std::process::Command` and existing `detect::get_bundle_id` are sufficient.
- Re-detect the terminal at paste time -- reuse `previous_app_pid` from AppState per user decision.
  </action>
  <verify>
Run `cd "/Users/lakshmanturlapati/Documents/Codes/CMD + K" && cd src-tauri && cargo check 2>&1 | tail -5` -- should compile with zero errors.
Verify paste.rs exists: `ls src-tauri/src/commands/paste.rs`
Verify registration: `grep paste_to_terminal src-tauri/src/lib.rs`
  </verify>
  <done>
paste_to_terminal Rust command compiles, is registered in Tauri handler, dispatches AppleScript by bundle ID for iTerm2 and Terminal.app, returns error for unsupported terminals.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add autoPasteEnabled Zustand state, PreferencesTab toggle, and App.tsx startup load</name>
  <files>
    src/store/index.ts
    src/components/Settings/PreferencesTab.tsx
    src/App.tsx
  </files>
  <action>
**Store (src/store/index.ts):**
1. Add to `OverlayState` interface, after the destructive detection block:
   ```
   // Auto-paste preference
   autoPasteEnabled: boolean;
   setAutoPasteEnabled: (enabled: boolean) => void;
   ```
2. Add initial state `autoPasteEnabled: true,` after `destructiveDetectionEnabled: true,`.
3. Add action implementation at the end (before the closing `})`):
   ```
   setAutoPasteEnabled: (enabled) => set({ autoPasteEnabled: enabled }),
   ```

**PreferencesTab (src/components/Settings/PreferencesTab.tsx):**
1. Add Zustand selectors for `autoPasteEnabled` and `setAutoPasteEnabled` (same pattern as destructiveDetectionEnabled).
2. Add `handleToggleAutoPaste` async handler identical in pattern to `handleToggleDestructive`:
   - Toggle the value, call `setAutoPasteEnabled`, persist to `settings.json` via `Store.load` + `store.set` + `store.save`.
3. Add a new section below the Safety section with:
   - Section header: `<p>` with text "Terminal" styled the same as "Safety" (text-white/40 text-xs uppercase tracking-wider mt-2).
   - Toggle row: label "Auto-paste to terminal" on the left, toggle button on right (exact same toggle component pattern as destructive toggle, but using `bg-blue-500/60` when enabled and `bg-white/10` when disabled).
   - When `autoPasteEnabled` is OFF (false), show a one-line warning label below the toggle: `<p className="text-amber-400/60 text-xs mt-1">Commands will not be pasted automatically</p>`. Do not show this label when toggle is ON.

**App.tsx startup load:**
1. In the `checkOnboarding` function, in BOTH the onboarding-incomplete branch (around line 58) AND the onboarding-complete branch (around line 108), add:
   ```typescript
   const autoPaste = await store.get<boolean>("autoPasteEnabled");
   useOverlayStore.getState().setAutoPasteEnabled(autoPaste ?? true);
   ```
   Place it right after the existing `destructiveDetectionEnabled` load in each branch.
  </action>
  <verify>
Run `cd "/Users/lakshmanturlapati/Documents/Codes/CMD + K" && npx tsc --noEmit 2>&1 | tail -5` -- should compile with zero TypeScript errors.
Verify store field: `grep autoPasteEnabled src/store/index.ts | head -5`
Verify toggle: `grep autoPasteEnabled src/components/Settings/PreferencesTab.tsx | head -5`
Verify startup load: `grep autoPasteEnabled src/App.tsx | head -3`
  </verify>
  <done>
autoPasteEnabled state field exists in Zustand store defaulting to true, PreferencesTab shows Terminal section with auto-paste toggle (blue when ON, warning label when OFF), App.tsx loads persisted value from settings.json on startup in both onboarding paths.
  </done>
</task>

</tasks>

<verification>
- `cargo check` passes with zero errors in src-tauri
- `npx tsc --noEmit` passes with zero TypeScript errors
- `paste_to_terminal` is registered in `generate_handler![]` in lib.rs
- `autoPasteEnabled` is in Zustand store interface, initial state, and has setter action
- PreferencesTab has auto-paste toggle with warning when disabled
- App.tsx loads autoPasteEnabled in both startup branches
</verification>

<success_criteria>
- Rust paste_to_terminal command compiles and is registered as Tauri IPC handler
- Frontend has autoPasteEnabled preference with persistence and UI toggle
- Both subsystems are independently testable and ready for wiring in Plan 02
</success_criteria>

<output>
After completion, create `.planning/phases/06-terminal-pasting/06-01-SUMMARY.md`
</output>
