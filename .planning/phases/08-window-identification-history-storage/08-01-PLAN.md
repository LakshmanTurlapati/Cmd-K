---
phase: 08-window-identification-history-storage
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src-tauri/src/state.rs
  - src-tauri/src/terminal/detect.rs
  - src-tauri/src/terminal/process.rs
  - src-tauri/src/commands/hotkey.rs
  - src-tauri/src/commands/history.rs
  - src-tauri/src/commands/mod.rs
  - src-tauri/src/lib.rs
autonomous: true
requirements: [WKEY-01, WKEY-02, WKEY-03, HIST-04]

must_haves:
  truths:
    - "Window key is computed synchronously in the hotkey handler before toggle_overlay() is called"
    - "Terminal tabs produce different window keys (bundle_id:shell_pid format)"
    - "Non-terminal apps produce per-app window keys (bundle_id:app_pid format) -- not a global bucket"
    - "VS Code is recognized as an IDE with an integrated terminal"
    - "History entries can be stored, retrieved, and evicted per window key via IPC commands"
    - "History is capped at 7 entries per window and 50 tracked windows total"
  artifacts:
    - path: "src-tauri/src/state.rs"
      provides: "AppState with current_window_key and history HashMap fields, HistoryEntry and TerminalContextSnapshot structs"
      contains: "current_window_key"
    - path: "src-tauri/src/commands/history.rs"
      provides: "get_window_key, get_window_history, add_history_entry IPC commands"
      exports: ["get_window_key", "get_window_history", "add_history_entry"]
    - path: "src-tauri/src/commands/hotkey.rs"
      provides: "Window key computation before toggle_overlay"
      contains: "compute_window_key"
    - path: "src-tauri/src/terminal/detect.rs"
      provides: "VS Code and Cursor IDE bundle ID detection"
      contains: "IDE_BUNDLE_IDS"
  key_links:
    - from: "src-tauri/src/commands/hotkey.rs"
      to: "src-tauri/src/state.rs"
      via: "Stores computed window key in AppState.current_window_key"
      pattern: "current_window_key\\.lock"
    - from: "src-tauri/src/commands/hotkey.rs"
      to: "src-tauri/src/terminal/detect.rs"
      via: "Calls get_bundle_id, is_known_terminal, is_ide_with_terminal"
      pattern: "detect::is_ide_with_terminal"
    - from: "src-tauri/src/commands/history.rs"
      to: "src-tauri/src/state.rs"
      via: "Reads/writes AppState.history HashMap"
      pattern: "state\\.history\\.lock"
    - from: "src-tauri/src/lib.rs"
      to: "src-tauri/src/commands/history.rs"
      via: "Registers IPC commands in invoke_handler"
      pattern: "get_window_key.*get_window_history.*add_history_entry"
---

<objective>
Build the Rust backend for per-window/tab identity and history storage. Compute a stable window key synchronously in the hotkey handler before the overlay appears, and provide IPC commands for storing/retrieving per-window query history.

Purpose: Foundation for Phase 9 (arrow-key history navigation) and Phase 10 (AI follow-up context). History must survive overlay open/close cycles by living in Rust AppState, not Zustand (which resets on every show()).

Output: Extended AppState with window key + history map, window key computation in hotkey handler, VS Code detection, and 3 new IPC commands (get_window_key, get_window_history, add_history_entry).
</objective>

<execution_context>
@/Users/lakshmanturlapati/.claude/get-shit-done/workflows/execute-plan.md
@/Users/lakshmanturlapati/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-window-identification-history-storage/08-CONTEXT.md
@.planning/phases/08-window-identification-history-storage/08-RESEARCH.md
@src-tauri/src/state.rs
@src-tauri/src/commands/hotkey.rs
@src-tauri/src/terminal/detect.rs
@src-tauri/src/terminal/process.rs
@src-tauri/src/terminal/mod.rs
@src-tauri/src/commands/mod.rs
@src-tauri/src/lib.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend AppState, add VS Code detection, and compute window key in hotkey handler</name>
  <files>
    src-tauri/src/state.rs
    src-tauri/src/terminal/detect.rs
    src-tauri/src/terminal/process.rs
    src-tauri/src/commands/hotkey.rs
  </files>
  <action>
**state.rs changes:**
1. Add `use std::collections::{HashMap, VecDeque};` to imports.
2. Add constants at module level:
   - `pub const MAX_HISTORY_PER_WINDOW: usize = 7;`
   - `pub const MAX_TRACKED_WINDOWS: usize = 50;`
3. Define `HistoryEntry` struct with `#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]`:
   - `query: String` -- the user's query text
   - `response: String` -- full AI response text (explanation + command + warnings)
   - `timestamp: u64` -- Unix milliseconds
   - `terminal_context: Option<TerminalContextSnapshot>` -- CWD, shell, output at time of query
   - `is_error: bool` -- whether the AI request failed/errored
4. Define `TerminalContextSnapshot` struct with `#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]`:
   - `cwd: Option<String>`
   - `shell_type: Option<String>`
   - `visible_output: Option<String>`
5. Add `impl HistoryEntry` with a `pub fn new(query, response, context, is_error) -> Self` constructor that auto-generates timestamp via `SystemTime::now().duration_since(UNIX_EPOCH)`.
6. Add two new fields to `AppState`:
   - `pub current_window_key: Mutex<Option<String>>` -- the window key for the current overlay invocation
   - `pub history: Mutex<HashMap<String, VecDeque<HistoryEntry>>>` -- per-window history map
7. Update `impl Default for AppState` to initialize both new fields: `current_window_key: Mutex::new(None)`, `history: Mutex::new(HashMap::new())`.

**detect.rs changes:**
1. Add `IDE_BUNDLE_IDS` constant after `TERMINAL_BUNDLE_IDS`:
   ```rust
   pub const IDE_BUNDLE_IDS: &[&str] = &[
       "com.microsoft.VSCode",
       "com.microsoft.VSCodeInsiders",
       "com.todesktop.230313mzl4w4u92", // Cursor
   ];
   ```
2. Add `pub fn is_ide_with_terminal(bundle_id: &str) -> bool` that checks `IDE_BUNDLE_IDS.contains(&bundle_id)`.

**process.rs changes:**
1. Change `find_shell_pid` visibility from `fn find_shell_pid` to `pub(crate) fn find_shell_pid` so it can be called from the hotkey handler for window key computation. Currently it is private and only called by `get_foreground_info`.

**hotkey.rs changes:**
1. Add import: `use crate::terminal;`  (the module, for `terminal::detect` and `terminal::process`).
2. Create a new private function `compute_window_key(pid: i32) -> String`:
   - Get `bundle_id` via `terminal::detect::get_bundle_id(pid)`.
   - Get `bundle_str` as `bundle_id.as_deref().unwrap_or("unknown")`.
   - Check `is_terminal` via `terminal::detect::is_known_terminal(bundle_str)`.
   - Check `is_ide` via `terminal::detect::is_ide_with_terminal(bundle_str)`.
   - If `is_terminal || is_ide`: try `terminal::process::find_shell_pid(pid)`. If `Some(shell_pid)` -> `format!("{}:{}", bundle_str, shell_pid)`. If `None` -> fall back to `format!("{}:{}", bundle_str, pid)`.
   - Else (non-terminal, non-IDE): `format!("{}:{}", bundle_str, pid)` -- this gives Finder, Safari, etc. their own per-app history bucket.
   - Add `eprintln!("[hotkey] computed window_key: {}", &key);` before returning.
3. In the `register_hotkey` handler, inside the `if !is_currently_visible` block, AFTER the existing `pre_captured_text` storage block and BEFORE `toggle_overlay(&app_handle)`:
   - Call `let window_key = compute_window_key(pid);` (using the `pid` variable from the outer `if let Some(pid) = pid` block).
   - Store it: `if let Some(state) = app_handle.try_state::<AppState>() { if let Ok(mut wk) = state.current_window_key.lock() { *wk = Some(window_key); } }`
   - This ensures WKEY-02: window key is captured synchronously alongside PID capture, before overlay steals focus.
  </action>
  <verify>
Run `cd "src-tauri" && cargo check 2>&1` -- must compile with zero errors. Warnings are acceptable.
  </verify>
  <done>
AppState has current_window_key and history fields. VS Code/Cursor recognized via IDE_BUNDLE_IDS. find_shell_pid is pub(crate). Window key computed and stored in hotkey handler before toggle_overlay. `cargo check` passes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create history IPC commands and register in lib.rs</name>
  <files>
    src-tauri/src/commands/history.rs
    src-tauri/src/commands/mod.rs
    src-tauri/src/lib.rs
  </files>
  <action>
**Create commands/history.rs (NEW file):**

1. `get_window_key` command:
   ```rust
   #[tauri::command]
   pub fn get_window_key(app: tauri::AppHandle) -> Option<String> {
       use tauri::Manager;
       let state = app.try_state::<crate::state::AppState>()?;
       state.current_window_key.lock().ok()?.clone()
   }
   ```

2. `get_window_history` command:
   ```rust
   #[tauri::command]
   pub fn get_window_history(app: tauri::AppHandle, window_key: String) -> Vec<crate::state::HistoryEntry> {
       use tauri::Manager;
       let state = match app.try_state::<crate::state::AppState>() {
           Some(s) => s,
           None => return Vec::new(),
       };
       let history = match state.history.lock() {
           Ok(h) => h,
           Err(_) => return Vec::new(),
       };
       history.get(&window_key)
           .map(|deque| deque.iter().cloned().collect())
           .unwrap_or_default()
   }
   ```

3. `add_history_entry` command -- this is called by the frontend after each query completes:
   ```rust
   #[tauri::command]
   pub fn add_history_entry(
       app: tauri::AppHandle,
       window_key: String,
       query: String,
       response: String,
       terminal_context: Option<crate::state::TerminalContextSnapshot>,
       is_error: bool,
   ) -> Result<(), String> {
       use tauri::Manager;
       use crate::state::{HistoryEntry, MAX_HISTORY_PER_WINDOW, MAX_TRACKED_WINDOWS};

       let state = app.try_state::<crate::state::AppState>()
           .ok_or("AppState not found")?;
       let mut history = state.history.lock()
           .map_err(|_| "History mutex poisoned".to_string())?;

       // Enforce MAX_TRACKED_WINDOWS limit before adding new key
       if !history.contains_key(&window_key) && history.len() >= MAX_TRACKED_WINDOWS {
           // Evict window with oldest most-recent entry
           let oldest_key = history.iter()
               .filter_map(|(k, v)| v.back().map(|e| (k.clone(), e.timestamp)))
               .min_by_key(|(_, ts)| *ts)
               .map(|(k, _)| k);
           if let Some(key) = oldest_key {
               eprintln!("[history] evicting oldest window: {}", key);
               history.remove(&key);
           }
       }

       let entries = history.entry(window_key.clone())
           .or_insert_with(std::collections::VecDeque::new);
       if entries.len() >= MAX_HISTORY_PER_WINDOW {
           entries.pop_front(); // evict oldest entry
       }

       let entry = HistoryEntry::new(query, response, terminal_context, is_error);
       entries.push_back(entry);
       eprintln!("[history] added entry for window '{}', total entries: {}", window_key, entries.len());

       Ok(())
   }
   ```

Note: Using individual parameters (query, response, terminal_context, is_error) instead of a single HistoryEntry parameter for the IPC command. This avoids requiring the frontend to construct the exact Rust struct shape with timestamp -- the backend generates the timestamp via `HistoryEntry::new()`. The frontend just passes the raw data.

**mod.rs change:**
Add `pub mod history;` to the module declarations.

**lib.rs changes:**
1. Add to the `use commands::` block: `history::{get_window_key, get_window_history, add_history_entry},`
2. Add to the `tauri::generate_handler![]` array: `get_window_key, get_window_history, add_history_entry,`
  </action>
  <verify>
Run `cd "src-tauri" && cargo check 2>&1` -- must compile with zero errors. Verify all three new commands appear in the generate_handler macro.
  </verify>
  <done>
Three new IPC commands (get_window_key, get_window_history, add_history_entry) are implemented, registered, and compile successfully. History enforces 7-entry-per-window cap and 50-window total cap with oldest-window eviction.
  </done>
</task>

</tasks>

<verification>
1. `cd "src-tauri" && cargo check` passes with no errors
2. `grep -n "current_window_key" src-tauri/src/state.rs` shows the new field
3. `grep -n "history" src-tauri/src/state.rs` shows the HashMap field
4. `grep -n "compute_window_key" src-tauri/src/commands/hotkey.rs` shows the function
5. `grep -n "IDE_BUNDLE_IDS" src-tauri/src/terminal/detect.rs` shows VS Code detection
6. `grep -n "get_window_key\|get_window_history\|add_history_entry" src-tauri/src/lib.rs` shows all 3 commands registered
7. `grep -n "pub(crate) fn find_shell_pid" src-tauri/src/terminal/process.rs` shows visibility change
</verification>

<success_criteria>
- cargo check passes cleanly (no errors)
- Window key computed synchronously before toggle_overlay in hotkey handler
- VS Code and Cursor bundle IDs added to IDE detection
- find_shell_pid is pub(crate) accessible
- HistoryEntry struct with query, response, timestamp, terminal_context, is_error
- 3 IPC commands registered: get_window_key, get_window_history, add_history_entry
- History capped at 7 per window, 50 windows total with LRU eviction
</success_criteria>

<output>
After completion, create `.planning/phases/08-window-identification-history-storage/08-01-SUMMARY.md`
</output>
