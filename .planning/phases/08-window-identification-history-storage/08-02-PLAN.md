---
phase: 08-window-identification-history-storage
plan: 02
type: execute
wave: 2
depends_on: [08-01]
files_modified:
  - src/store/index.ts
autonomous: true
requirements: [WKEY-01, WKEY-02, HIST-04]

must_haves:
  truths:
    - "Frontend fetches window key from Rust on every overlay show, before the user can type"
    - "Frontend fetches per-window history from Rust on overlay show using the retrieved window key"
    - "After a query completes (success or error), the frontend calls add_history_entry to persist the entry in Rust"
    - "Window key and history are stored in Zustand for downstream consumption by Phase 9 and Phase 10"
    - "Failed/errored queries are also saved to history (is_error: true)"
  artifacts:
    - path: "src/store/index.ts"
      provides: "windowKey, windowHistory state + setWindowKey, setWindowHistory actions + IPC integration in show() and submitQuery()"
      contains: "windowKey"
  key_links:
    - from: "src/store/index.ts show()"
      to: "get_window_key IPC"
      via: "invoke('get_window_key') in show() async block after context detection starts"
      pattern: "invoke.*get_window_key"
    - from: "src/store/index.ts show()"
      to: "get_window_history IPC"
      via: "invoke('get_window_history', { windowKey }) after window key is fetched"
      pattern: "invoke.*get_window_history"
    - from: "src/store/index.ts submitQuery()"
      to: "add_history_entry IPC"
      via: "invoke('add_history_entry', { windowKey, query, response, ... }) after streaming completes"
      pattern: "invoke.*add_history_entry"
---

<objective>
Wire the frontend Zustand store to the Rust-side window key and history IPC commands. The overlay's show() action fetches the window key and history on every open, and submitQuery() persists each completed query to Rust-side history.

Purpose: Makes window identity and history available to the UI layer for Phase 9 (arrow-key navigation) and Phase 10 (AI follow-up context). Zustand holds a copy for rendering; Rust AppState is the source of truth that survives overlay cycles.

Output: Updated store/index.ts with windowKey/windowHistory state, IPC calls in show() and submitQuery().
</objective>

<execution_context>
@/Users/lakshmanturlapati/.claude/get-shit-done/workflows/execute-plan.md
@/Users/lakshmanturlapati/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-window-identification-history-storage/08-CONTEXT.md
@.planning/phases/08-window-identification-history-storage/08-RESEARCH.md
@.planning/phases/08-window-identification-history-storage/08-01-SUMMARY.md
@src/store/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add window key and history state to Zustand store with IPC integration</name>
  <files>src/store/index.ts</files>
  <action>
**Add HistoryEntry TypeScript interface** (after TurnMessage interface):
```typescript
export interface TerminalContextSnapshot {
  cwd: string | null;
  shell_type: string | null;
  visible_output: string | null;
}

export interface HistoryEntry {
  query: string;
  response: string;
  timestamp: number;
  terminal_context: TerminalContextSnapshot | null;
  is_error: boolean;
}
```

**Add state fields to OverlayState interface:**
- `windowKey: string | null;` -- the current window's identity key
- `windowHistory: HistoryEntry[];` -- history entries for the current window

**Add action declarations to OverlayState interface:**
- `setWindowKey: (key: string | null) => void;`
- `setWindowHistory: (history: HistoryEntry[]) => void;`

**Add initial state values in create():**
- `windowKey: null,`
- `windowHistory: [],`

**Add action implementations:**
- `setWindowKey: (key) => set({ windowKey: key }),`
- `setWindowHistory: (history) => set({ windowHistory: history }),`

**Modify show() action:**
In the existing async IIFE inside show(), add window key + history fetch AFTER the existing `invoke("check_accessibility_permission")` call but BEFORE the `get_app_context` call. Rationale: window key is synchronous on the Rust side and very fast (already computed in hotkey handler), so it should be available immediately. History fetch depends on the key.

Add this block inside the try block of the async IIFE, after the accessibility check and before `get_app_context`:
```typescript
// Fetch window key (computed synchronously by hotkey handler before overlay showed)
const windowKey = await invoke<string | null>("get_window_key");
console.log("[store] window key:", windowKey);
if (windowKey) {
  useOverlayStore.getState().setWindowKey(windowKey);
  // Fetch existing history for this window
  const history = await invoke<HistoryEntry[]>("get_window_history", { windowKey });
  console.log("[store] window history entries:", history.length);
  useOverlayStore.getState().setWindowHistory(history);
} else {
  useOverlayStore.getState().setWindowKey(null);
  useOverlayStore.getState().setWindowHistory([]);
}
```

Also add `windowKey: null, windowHistory: [],` to the reset state in show()'s synchronous `set()` call (alongside the existing `appContext: null, isDetectingContext: true`). This clears stale window key/history from the previous overlay open before fresh values arrive.

**Modify submitQuery() action:**
After streaming completes and turn history is built (after `const trimmedHistory = ...` line), add a call to persist the entry to Rust. This must happen in ALL three outcome branches (destructive, safe, and empty response) plus the catch block (for errors).

Create a helper at the top of the async IIFE (after `const state = useOverlayStore.getState()` line):
```typescript
const currentWindowKey = useOverlayStore.getState().windowKey;
```

Then, after streaming completes and BEFORE the destructive/safe/empty branching:
```typescript
// Persist to Rust-side history (survives overlay close/reopen)
if (currentWindowKey) {
  const historyCtx = appContext?.terminal ? {
    cwd: appContext.terminal.cwd,
    shell_type: appContext.terminal.shell_type,
    visible_output: appContext.terminal.visible_output,
  } : null;

  invoke("add_history_entry", {
    windowKey: currentWindowKey,
    query,
    response: fullText,
    terminalContext: historyCtx,
    isError: false,
  }).catch((err) => {
    console.error("[store] add_history_entry failed:", err);
  });
}
```

In the catch block (error case), add similarly but with `isError: true`:
```typescript
// Persist failed query to history too (user may want to retry via arrow-key recall)
const errWindowKey = useOverlayStore.getState().windowKey;
if (errWindowKey) {
  invoke("add_history_entry", {
    windowKey: errWindowKey,
    query,
    response: "",
    terminalContext: null,
    isError: true,
  }).catch((histErr) => {
    console.error("[store] add_history_entry (error case) failed:", histErr);
  });
}
```

IMPORTANT: The `add_history_entry` invoke uses fire-and-forget (.catch() for logging only). It should NOT block the UI flow or the set() calls that update display state. The history is persisted to Rust asynchronously.

NOTE on Tauri IPC snake_case: The Rust command parameter `terminal_context` maps to `terminalContext` in the JS invoke call (Tauri automatically converts camelCase to snake_case for command parameters). Similarly `is_error` maps to `isError`, and `window_key` maps to `windowKey`.
  </action>
  <verify>
1. Run `cd "src" && npx tsc --noEmit 2>&1` (or from project root: `npm run build 2>&1` if available) -- must compile with no TypeScript errors.
2. Verify `grep -n "get_window_key\|get_window_history\|add_history_entry" src/store/index.ts` shows all three IPC calls.
3. Verify `grep -n "windowKey\|windowHistory" src/store/index.ts` shows the new state fields.
  </verify>
  <done>
Zustand store has windowKey and windowHistory state fields. show() fetches window key and history from Rust on every overlay open. submitQuery() persists each completed query (including errors) to Rust-side history via add_history_entry IPC. TypeScript compiles cleanly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Build verification and end-to-end check</name>
  <files>
    src/store/index.ts
    src-tauri/src/lib.rs
  </files>
  <action>
Run a full build to verify both Rust and TypeScript compile together:

1. Run `cargo check` from `src-tauri/` directory to verify Rust compilation.
2. Run TypeScript check from project root (either `npx tsc --noEmit` or `npm run build` depending on available scripts).
3. Verify the complete IPC chain by grepping:
   - Rust side: `grep -rn "get_window_key\|get_window_history\|add_history_entry" src-tauri/src/` -- should show the command definitions AND the generate_handler registration.
   - Frontend side: `grep -rn "get_window_key\|get_window_history\|add_history_entry" src/` -- should show the invoke calls.
4. Verify window key computation:
   - `grep -n "compute_window_key" src-tauri/src/commands/hotkey.rs` -- shows the function exists.
   - `grep -n "current_window_key" src-tauri/src/commands/hotkey.rs` -- shows it is stored in AppState.
5. Verify the show() action resets windowKey/windowHistory and then fetches fresh values:
   - Check that `windowKey: null` appears in the synchronous set() call of show().
   - Check that `invoke.*get_window_key` appears in the async block of show().

If any step fails, fix the issue before marking complete.
  </action>
  <verify>
`cargo check` and TypeScript compilation both pass. All grep checks return expected matches.
  </verify>
  <done>
Full Rust + TypeScript build passes. All IPC commands are properly registered on the Rust side and invoked from the frontend. Window key and history flow is complete: hotkey handler computes key -> AppState stores it -> show() fetches it -> submitQuery() persists entries -> next show() retrieves history.
  </done>
</task>

</tasks>

<verification>
1. `cargo check` from src-tauri/ passes
2. TypeScript compilation passes (no type errors)
3. Window key flow: hotkey.rs compute_window_key -> AppState.current_window_key -> get_window_key IPC -> Zustand windowKey
4. History flow: submitQuery() -> add_history_entry IPC -> AppState.history -> get_window_history IPC -> Zustand windowHistory
5. show() resets windowKey/windowHistory before fetching fresh values
6. Failed queries are persisted with is_error: true
</verification>

<success_criteria>
- Full project builds (Rust + TypeScript) with no errors
- windowKey and windowHistory are available in Zustand state
- show() fetches window key and history from Rust on every overlay open
- submitQuery() persists entries to Rust history (success and error cases)
- History entries include query, response, terminal context snapshot, timestamp, and error flag
</success_criteria>

<output>
After completion, create `.planning/phases/08-window-identification-history-storage/08-02-SUMMARY.md`
</output>
