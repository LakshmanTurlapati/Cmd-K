---
phase: 08-window-identification-history-storage
plan: 03
type: execute
wave: 1
depends_on: ["08-01", "08-02"]
files_modified:
  - src-tauri/src/terminal/process.rs
  - src-tauri/src/terminal/ax_reader.rs
  - src-tauri/src/commands/hotkey.rs
autonomous: true
requirements: [WKEY-01]
gap_closure: true

must_haves:
  truths:
    - "Cursor/VS Code with multiple terminal tabs produces different window keys when different tabs are focused"
    - "The AX-based focused tab detection falls back to highest-PID heuristic when AX data is unavailable"
    - "Terminal.app and iTerm2 behavior is unchanged (fast path still works for shallow process trees)"
  artifacts:
    - path: "src-tauri/src/terminal/ax_reader.rs"
      provides: "get_focused_terminal_cwd function that extracts CWD from AXFocusedUIElement text"
      contains: "get_focused_terminal_cwd"
    - path: "src-tauri/src/terminal/process.rs"
      provides: "AX-aware shell selection in find_shell_by_ancestry that matches focused tab CWD against candidate shell CWDs"
      contains: "focused_cwd"
    - path: "src-tauri/src/commands/hotkey.rs"
      provides: "Pre-captured focused terminal CWD passed through to find_shell_pid"
  key_links:
    - from: "src-tauri/src/commands/hotkey.rs"
      to: "src-tauri/src/terminal/ax_reader.rs"
      via: "get_focused_terminal_cwd called in hotkey handler before toggle_overlay"
      pattern: "get_focused_terminal_cwd"
    - from: "src-tauri/src/terminal/process.rs"
      to: "get_process_cwd"
      via: "CWD comparison between focused tab CWD and each candidate shell CWD"
      pattern: "get_process_cwd.*focused_cwd"
---

<objective>
Fix multi-tab Electron IDE shell PID resolution so each focused terminal tab produces a distinct window key.

Purpose: UAT Test 1 revealed that Cursor IDE with 3 terminal tabs always resolves to shell PID 83090 regardless of which tab is active. The `find_shell_by_ancestry` function uses a highest-PID heuristic that does not reflect tab focus. This gap closure adds AX-based focused tab detection: extract the CWD visible in the focused terminal tab via AXFocusedUIElement, compare it against the CWDs of all candidate shell PIDs, and return the matching shell. Falls back to highest-PID if AX data is unavailable or no CWD match is found.

Output: Modified process.rs with AX-aware shell selection, new ax_reader function for focused terminal CWD extraction, updated hotkey.rs to pre-capture focused CWD.
</objective>

<execution_context>
@/Users/lakshmanturlapati/.claude/get-shit-done/workflows/execute-plan.md
@/Users/lakshmanturlapati/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-window-identification-history-storage/08-01-SUMMARY.md
@.planning/phases/08-window-identification-history-storage/08-02-SUMMARY.md
@.planning/debug/cursor-multi-tab-same-pid.md

Key source files:
@src-tauri/src/terminal/process.rs (find_shell_by_ancestry at line 340-437 -- the flawed highest-PID heuristic at line 435)
@src-tauri/src/terminal/ax_reader.rs (existing AX infrastructure -- get_ax_attribute, cf_type_to_string, ensure_ax_tree_active, AXFocusedUIElement)
@src-tauri/src/commands/hotkey.rs (compute_window_key at line 67-84, hotkey handler capturing at line 146-180)
@src-tauri/src/terminal/detect.rs (IDE_BUNDLE_IDS, is_ide_with_terminal)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add AX-based focused terminal CWD extraction and pre-capture in hotkey handler</name>
  <files>src-tauri/src/terminal/ax_reader.rs, src-tauri/src/commands/hotkey.rs, src-tauri/src/state.rs</files>
  <action>
**In `src-tauri/src/terminal/ax_reader.rs`:**

Add a new public function `get_focused_terminal_cwd(app_pid: i32) -> Option<String>` that extracts the CWD path from the focused terminal tab's AX element. The algorithm:

1. Create an AXUIElement for the app PID (same as existing `read_terminal_text`).
2. Set a short messaging timeout (0.3s -- this runs in the hotkey handler path so must be fast).
3. Call `ensure_ax_tree_active(app_pid)` to wake up Electron AX trees.
4. Get `AXFocusedUIElement` from the app element using the existing `get_ax_attribute` function.
5. From the focused element, read `AXValue` (the terminal text content) using `get_ax_string_value`.
6. Also read `AXTitle` from the focused element using `get_ax_attribute` with "AXTitle" and `cf_type_to_string` -- the tab title in Cursor/VS Code typically contains the CWD (e.g., "zsh - /Users/foo/project" or "node /Users/foo/project").
7. Try to extract a path from the title first (more reliable): look for a path pattern starting with "/" that exists as a directory. Use `std::path::Path::new(candidate).is_dir()` to verify.
8. If no path found in title, try extracting from the last line of AXValue text (the shell prompt often contains the CWD).
9. Return `Some(path_string)` if a valid directory path was found, `None` otherwise.
10. CFRelease all AX refs properly (follow the existing patterns in the file).
11. Add the corresponding non-macOS stub: `pub fn get_focused_terminal_cwd(_app_pid: i32) -> Option<String> { None }`

The function should be added in the `macos` module (as `pub(super)`) and exposed with a public wrapper (same pattern as `read_focused_text_fast`).

Important: The title parsing should handle these common Cursor/VS Code terminal tab title formats:
- "zsh - /Users/foo/project" (split on " - " and take the path part)
- "1: zsh - /Users/foo/project" (tab number prefix)
- "/Users/foo/project" (just the path)
- "node server.js" (no path -- return None for this one, fall through to AXValue check)

**In `src-tauri/src/state.rs`:**

Add a new field to AppState:
```rust
pub pre_captured_focused_cwd: Mutex<Option<String>>,
```
Initialize it to `Mutex::new(None)` in the AppState::default() or wherever AppState is constructed.

**In `src-tauri/src/commands/hotkey.rs`:**

Inside the `if !is_currently_visible` block, AFTER the PID capture and AX text pre-capture but BEFORE `compute_window_key`:

1. Check if the frontmost app is an IDE with terminal: call `terminal::detect::get_bundle_id(pid)` (already done by compute_window_key, but we need it earlier) and `terminal::detect::is_ide_with_terminal(bundle_str)`.
2. If it IS an IDE, call `ax_reader::get_focused_terminal_cwd(pid)` to get the focused tab's CWD.
3. Store the result in `state.pre_captured_focused_cwd`.
4. Pass the focused CWD into `compute_window_key` by changing its signature to `compute_window_key(pid: i32, focused_cwd: Option<String>) -> String`.
5. In `compute_window_key`, when calling `find_shell_pid`, pass the focused_cwd along. Change `find_shell_pid` signature to accept `focused_cwd: Option<&str>` (see Task 2).
6. For the `else` (overlay visible / hiding) case, also clear `pre_captured_focused_cwd` to None.

The focused CWD capture MUST happen BEFORE `toggle_overlay()` because after the overlay steals focus, AXFocusedUIElement will point to the overlay, not the IDE's terminal tab.
  </action>
  <verify>
Run `cargo check` from `src-tauri/` directory -- zero errors. Verify `get_focused_terminal_cwd` function exists in ax_reader.rs. Verify `pre_captured_focused_cwd` field in state.rs. Verify hotkey.rs calls `get_focused_terminal_cwd` before `compute_window_key`.
  </verify>
  <done>
New `get_focused_terminal_cwd` function in ax_reader.rs extracts CWD from focused terminal tab's AX title/value. Hotkey handler pre-captures focused CWD for IDEs before overlay steals focus. The focused CWD is passed through to compute_window_key.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add AX-aware shell selection in find_shell_by_ancestry</name>
  <files>src-tauri/src/terminal/process.rs</files>
  <action>
Modify `find_shell_pid` and `find_shell_by_ancestry` to accept an optional focused CWD and use it to disambiguate between multiple candidate shells.

**Changes to `find_shell_pid`:**

Change signature from:
```rust
pub(crate) fn find_shell_pid(terminal_pid: i32) -> Option<i32>
```
to:
```rust
pub(crate) fn find_shell_pid(terminal_pid: i32, focused_cwd: Option<&str>) -> Option<i32>
```

Pass `focused_cwd` through to `find_shell_by_ancestry`. The fast path (`find_shell_recursive`) does NOT need focused_cwd because it only returns a result when there is exactly one shell in a shallow tree (Terminal.app, iTerm2 single tab), where ambiguity does not arise.

**Changes to `find_shell_by_ancestry`:**

Change signature to accept `focused_cwd: Option<&str>`.

After Step 2 (the mixed-shell-type filtering at line 430-432) and BEFORE Step 3 (the highest-PID fallback at line 434-436), add a new Step 2.5: **CWD-based focused tab matching**.

The algorithm for Step 2.5:
```
if let Some(ref target_cwd) = focused_cwd {
    if candidates.len() > 1 {
        // For each candidate shell PID, get its CWD
        let mut cwd_matches: Vec<&(i32, Option<String>)> = Vec::new();
        for candidate in &candidates {
            if let Some(shell_cwd) = get_process_cwd(candidate.0) {
                eprintln!("[process] shell pid {} CWD: {}", candidate.0, &shell_cwd);
                if shell_cwd == *target_cwd {
                    cwd_matches.push(candidate);
                }
            }
        }
        if cwd_matches.len() == 1 {
            let matched = cwd_matches[0];
            eprintln!("[process] CWD match: shell pid {} matches focused tab CWD {}", matched.0, target_cwd);
            return Some(matched.0);
        } else if cwd_matches.len() > 1 {
            eprintln!("[process] {} shells match focused CWD {} -- falling through to highest PID among matches", cwd_matches.len(), target_cwd);
            // Multiple shells in the same CWD -- pick highest PID among matches (best we can do)
            return cwd_matches.iter().max_by_key(|(pid, _)| *pid).map(|(pid, _)| *pid);
        }
        // No CWD match found -- fall through to Step 3 (highest PID)
        eprintln!("[process] no CWD match for focused tab CWD {} among {} candidates", target_cwd, candidates.len());
    }
}
```

Step 3 (highest PID) remains as the final fallback, unchanged.

**Also update callers:**

In `get_foreground_info` (line 93), the call to `find_shell_pid` needs to pass `None` for focused_cwd since get_foreground_info is used for terminal context detection, not window key computation:
```rust
let shell_pid = match find_shell_pid(terminal_pid, None) {
```

Add `eprintln!` logging at each decision point so the behavior can be observed in stderr during testing.

**Non-macOS stubs:**

Update the non-macOS stub of `find_shell_by_ancestry` to accept the new parameter:
```rust
fn find_shell_by_ancestry(_app_pid: i32, _focused_cwd: Option<&str>) -> Option<i32> { None }
```

Update the non-macOS stub of `find_shell_pid` if one exists to match the new signature.
  </action>
  <verify>
Run `cargo check` from `src-tauri/` directory -- zero errors. Verify that `find_shell_pid` and `find_shell_by_ancestry` both accept the focused_cwd parameter. Verify that the CWD matching logic exists between the mixed-type filter and the highest-PID fallback. Verify that `get_foreground_info` passes `None` for focused_cwd. Run `cargo build` to confirm full compilation.
  </verify>
  <done>
`find_shell_by_ancestry` now uses AX-derived focused tab CWD to match against candidate shell CWDs before falling back to highest-PID. When a unique CWD match is found, the correct focused tab's shell PID is returned. When no match is found (AX unavailable, CWD not in candidates, or multiple matches), the existing highest-PID heuristic is preserved as fallback. Terminal.app and iTerm2 behavior is unchanged because they use the fast path (find_shell_recursive) and never reach find_shell_by_ancestry.
  </done>
</task>

</tasks>

<verification>
1. `cargo check` in src-tauri/ passes with zero new errors
2. `cargo build` in src-tauri/ compiles successfully
3. Code review: `find_shell_by_ancestry` has CWD matching BEFORE highest-PID fallback
4. Code review: `get_focused_terminal_cwd` extracts path from AX title/value
5. Code review: hotkey.rs pre-captures focused CWD for IDEs only (not for Terminal.app/iTerm2)
6. Code review: `get_foreground_info` passes None for focused_cwd (no behavior change for terminal context detection)
</verification>

<success_criteria>
- Cursor IDE with 3 terminal tabs in different directories produces different window keys when different tabs are focused (the AX-derived CWD matches the focused tab's shell PID)
- Terminal.app and iTerm2 continue to work unchanged (shallow process tree hits fast path, never reaches CWD matching)
- Non-terminal apps unaffected (focused_cwd is None for non-IDEs)
- When AX data is unavailable (GPU terminals, accessibility not granted), falls back gracefully to highest-PID heuristic
- All existing functionality preserved -- no regressions in window key computation for any app type
</success_criteria>

<output>
After completion, create `.planning/phases/08-window-identification-history-storage/08-03-SUMMARY.md`
</output>
