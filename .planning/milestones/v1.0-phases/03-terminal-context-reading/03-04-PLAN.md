---
phase: 03-terminal-context-reading
plan: 04
type: execute
wave: 3
depends_on: ["03-02"]
files_modified:
  - src-tauri/src/terminal/mod.rs
  - src-tauri/src/terminal/detect.rs
  - src-tauri/src/terminal/browser.rs
  - src-tauri/src/commands/terminal.rs
  - src-tauri/src/lib.rs
  - src-tauri/capabilities/default.json
autonomous: true
requirements: [TERM-03, TERM-04]

must_haves:
  truths:
    - "get_terminal_context returns an AppContext struct that includes app_name for ANY frontmost app, not just terminals"
    - "App display name is resolved from NSRunningApplication.localizedName via ObjC FFI"
    - "App names are cleaned/shortened: 'Google Chrome' -> 'Chrome', 'Visual Studio Code' -> 'Code', 'Mozilla Firefox' -> 'Firefox'"
    - "Known browser bundle IDs are identified: Chrome, Safari, Firefox, Arc, Edge, Brave"
    - "When shell is detected inside an app (e.g., Cursor), app_name is still populated but badge logic defers to shell"
    - "Browser console detection via AX tree: looks for DevTools/Web Inspector window or panel"
    - "When DevTools console is detected in a browser, console_detected is true in response"
    - "Last line of console output is read from DevTools AX text area and included as console_last_line"
    - "Chromium-based browsers (Arc, Edge, Brave) have their own display name, not 'Chrome'"
  artifacts:
    - path: "src-tauri/src/terminal/detect.rs"
      provides: "Extended detection with browser bundle IDs, app name resolution, and name cleaning"
      contains: "get_app_display_name"
    - path: "src-tauri/src/terminal/browser.rs"
      provides: "Browser console detection via AX tree, last line reading"
      contains: "detect_console"
    - path: "src-tauri/src/terminal/mod.rs"
      provides: "AppContext struct wrapping TerminalContext + app_name + console state"
      contains: "pub struct AppContext"
    - path: "src-tauri/src/commands/terminal.rs"
      provides: "Updated IPC command returning AppContext"
      contains: "AppContext"
  key_links:
    - from: "src-tauri/src/terminal/detect.rs"
      to: "NSRunningApplication"
      via: "ObjC FFI localizedName for display name resolution"
      pattern: "localizedName"
    - from: "src-tauri/src/terminal/browser.rs"
      to: "src-tauri/src/terminal/ax_reader.rs"
      via: "Reuses AX tree walking patterns for DevTools detection"
      pattern: "AXUIElementCreateApplication"
    - from: "src-tauri/src/commands/terminal.rs"
      to: "src-tauri/src/terminal/mod.rs"
      via: "Returns AppContext from detect_app_context()"
      pattern: "detect_app_context"
---

<objective>
Extend the context detection backend to support app-aware badges and browser console detection.

Purpose: The updated phase decisions require that every frontmost app gets a badge (not just terminals), browser DevTools console state is detected, and app names are cleaned/shortened for display. This plan adds app name resolution, browser console detection via AX tree, and restructures the IPC response to carry all context types.

Output: Extended `detect.rs` with app name resolution, new `browser.rs` for console detection, `AppContext` wrapper struct in `mod.rs`, updated `commands/terminal.rs` IPC command.
</objective>

<execution_context>
@/Users/lakshmanturlapati/.claude/get-shit-done/workflows/execute-plan.md
@/Users/lakshmanturlapati/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-terminal-context-reading/03-CONTEXT.md
@.planning/phases/03-terminal-context-reading/03-RESEARCH.md
@.planning/phases/03-terminal-context-reading/03-01-SUMMARY.md
@.planning/phases/03-terminal-context-reading/03-02-SUMMARY.md

Key files:
@src-tauri/src/terminal/mod.rs (TerminalContext struct, detect() with 500ms timeout)
@src-tauri/src/terminal/detect.rs (get_bundle_id, is_known_terminal, is_gpu_terminal, TERMINAL_BUNDLE_IDS)
@src-tauri/src/terminal/ax_reader.rs (AX tree walk patterns to reuse for console detection)
@src-tauri/src/terminal/process.rs (find_shell_by_ancestry works for editors with integrated terminals)
@src-tauri/src/commands/terminal.rs (get_terminal_context IPC command to update)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add app name resolution, browser detection, and name cleaning to detect.rs</name>
  <files>
    src-tauri/src/terminal/detect.rs
  </files>
  <action>
    Extend detect.rs with three new capabilities:

    1. **App display name resolution** -- add `get_app_display_name(pid: i32) -> Option<String>`:
       - Uses NSRunningApplication ObjC FFI (same pattern as existing get_bundle_id)
       - Calls `[NSRunningApplication runningApplicationWithProcessIdentifier:pid].localizedName`
       - `localizedName` is a property returning the user-visible app name
       - Uses the existing ARM64-safe MsgSendI32 pattern from get_bundle_id for the pid argument
       - For the localizedName call (no extra args), use standard variadic objc_msgSend
       - Convert NSString -> Rust String via UTF8String (same as bundle_id conversion)
       - Returns the raw localized name before cleaning

    2. **App name cleaning** -- add `clean_app_name(raw_name: &str) -> String`:
       A static mapping table for common macOS apps that should be shortened:
       ```rust
       const APP_NAME_MAP: &[(&str, &str)] = &[
           ("Google Chrome", "Chrome"),
           ("Visual Studio Code", "Code"),
           ("Visual Studio Code - Insiders", "Code"),
           ("Mozilla Firefox", "Firefox"),
           ("Microsoft Edge", "Edge"),
           ("Brave Browser", "Brave"),
           // Arc, Safari, Finder already have clean names
       ];
       ```
       Look up raw_name in the map. If found, return the short name. Otherwise return the raw name as-is.
       Also strip common suffixes like " - Insiders" or " Beta" if not in the explicit map.

    3. **Browser bundle ID list** -- add constant and helper:
       ```rust
       pub const BROWSER_BUNDLE_IDS: &[(&str, &str)] = &[
           ("com.google.Chrome", "Chrome"),
           ("com.apple.Safari", "Safari"),
           ("org.mozilla.firefox", "Firefox"),
           ("company.thebrowser.Browser", "Arc"),
           ("com.microsoft.edgemac", "Edge"),
           ("com.brave.Browser", "Brave"),
       ];

       pub fn is_known_browser(bundle_id: &str) -> bool {
           BROWSER_BUNDLE_IDS.iter().any(|(id, _)| *id == bundle_id)
       }

       pub fn browser_display_name(bundle_id: &str) -> Option<&'static str> {
           BROWSER_BUNDLE_IDS.iter()
               .find(|(id, _)| *id == bundle_id)
               .map(|(_, name)| *name)
       }
       ```
       IMPORTANT per CONTEXT.md: Chromium-based browsers (Arc, Edge, Brave) show their OWN name, not "Chrome".

    All new functions should follow the existing pattern: `#[cfg(target_os = "macos")]` with non-macOS stubs returning None/empty.
  </action>
  <verify>
    Run `cd src-tauri && cargo check` -- must compile with zero errors.
    Verify app name function exists: `grep "get_app_display_name" src-tauri/src/terminal/detect.rs`.
    Verify browser list exists: `grep "BROWSER_BUNDLE_IDS" src-tauri/src/terminal/detect.rs`.
    Verify name cleaning: `grep "clean_app_name\|APP_NAME_MAP" src-tauri/src/terminal/detect.rs`.
  </verify>
  <done>
    detect.rs has get_app_display_name() resolving localized name via ObjC FFI, clean_app_name() with mapping table for common apps, BROWSER_BUNDLE_IDS with 6 browsers, is_known_browser() and browser_display_name() helpers. `cargo check` passes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create browser.rs for console detection, add AppContext struct, update IPC command</name>
  <files>
    src-tauri/src/terminal/browser.rs
    src-tauri/src/terminal/mod.rs
    src-tauri/src/commands/terminal.rs
  </files>
  <action>
    **terminal/browser.rs:** Browser DevTools/Console detection via Accessibility API.

    Create a module that detects whether a browser has its DevTools console open and reads the last line of console output.

    ```rust
    /// Detect DevTools/Console in a browser window via Accessibility API.
    /// Returns (console_detected: bool, last_line: Option<String>).
    pub fn detect_console(app_pid: i32, bundle_id: &str) -> (bool, Option<String>)
    ```

    Implementation strategy:
    - Create AXApplication element for the browser PID
    - Set messaging timeout to 1.0 seconds (same as ax_reader.rs)
    - Walk the AX tree looking for indicators of DevTools:
      - For Chrome/Chromium-based browsers: look for a window or group with "DevTools" in its title (kAXTitleAttribute), or an AXSplitGroup containing a web area with DevTools content
      - For Safari: look for "Web Inspector" window (separate window, not a pane)
      - For Firefox: look for "Developer Tools" in window title or a split containing the devtools panel
    - The simplest reliable heuristic: enumerate all windows of the app, check if any window title contains "DevTools", "Web Inspector", "Developer Tools", or "Console"
    - If DevTools detected, try to find the console text area and read the last line:
      - Walk into the DevTools window -> find AXTextArea or AXStaticText elements
      - Read kAXValueAttribute, split by newlines, take the last non-empty line
      - Apply filter::filter_sensitive() to the last line before returning
    - If console text cannot be read (common -- DevTools AX exposure varies), return (true, None) -- we still know the console is open even without text

    Use the same raw CF FFI pattern from ax_reader.rs (inline extern "C" declarations for CFRelease, CFRetain, CFStringCreateWithBytes, CFArrayGetCount, CFArrayGetValueAtIndex, etc.).

    Reuse these AX helpers by either:
    a. Making the helper functions in ax_reader.rs `pub(crate)` and importing them, OR
    b. Creating a small shared AX utility module

    Option (a) is simpler -- make `get_ax_attribute`, `get_ax_string_value`, `get_ax_role` in ax_reader.rs `pub(crate)` so browser.rs can use them.

    If making ax_reader functions pub(crate) is too invasive, duplicate the minimal helpers needed (get_ax_attribute, get_ax_string_value for title reading). Keep it pragmatic.

    IMPORTANT: Per CONTEXT.md, only read the VERY LAST LINE of console output to avoid context bloat. Do not read the full console text.

    Safari's Web Inspector is treated the same as Chrome DevTools for detection purposes.

    **terminal/mod.rs:** Add the new module and AppContext struct.

    1. Add `pub mod browser;` to module declarations.

    2. Add the AppContext struct that wraps everything:
    ```rust
    /// Full context about the frontmost application, returned to the frontend.
    /// Includes app identity, terminal context (if applicable), and browser console state.
    #[derive(Debug, Clone, Serialize)]
    pub struct AppContext {
        /// Display name of the frontmost app, cleaned for badge display.
        /// e.g., "Chrome", "Code", "Terminal", "Finder"
        pub app_name: Option<String>,
        /// Terminal context (CWD, shell type, visible output, running process).
        /// Present when frontmost app is a terminal or has an integrated terminal with a shell.
        pub terminal: Option<TerminalContext>,
        /// Whether browser DevTools console was detected.
        pub console_detected: bool,
        /// Last line from browser console output (filtered for sensitive data).
        pub console_last_line: Option<String>,
    }
    ```

    3. Add a new orchestrator function `detect_app_context()`:
    ```rust
    pub fn detect_app_context(previous_app_pid: i32) -> Option<AppContext> {
        // 1. Get bundle ID and display name
        let bundle_id = detect::get_bundle_id(previous_app_pid);
        let raw_name = detect::get_app_display_name(previous_app_pid);
        let app_name = raw_name.map(|n| detect::clean_app_name(&n));

        // 2. Check terminal context (existing logic from detect_inner)
        let is_terminal = bundle_id.as_deref().map_or(false, detect::is_known_terminal);
        let proc_info = process::get_foreground_info(previous_app_pid);
        let has_shell = proc_info.shell_type.is_some() || proc_info.cwd.is_some();

        let terminal = if has_shell {
            let visible_output = if is_terminal {
                let is_gpu = bundle_id.as_deref().map_or(true, detect::is_gpu_terminal);
                if !is_gpu {
                    ax_reader::read_terminal_text(previous_app_pid, bundle_id.as_deref().unwrap_or(""))
                        .map(|text| filter::filter_sensitive(&text))
                } else {
                    None
                }
            } else {
                None
            };

            Some(TerminalContext {
                shell_type: proc_info.shell_type,
                cwd: proc_info.cwd,
                visible_output,
                running_process: proc_info.running_process,
            })
        } else {
            None
        };

        // 3. Check browser console (only for known browsers without a shell)
        let is_browser = bundle_id.as_deref().map_or(false, detect::is_known_browser);
        let (console_detected, console_last_line) = if is_browser && terminal.is_none() {
            let (detected, line) = browser::detect_console(previous_app_pid, bundle_id.as_deref().unwrap_or(""));
            let filtered_line = line.map(|l| filter::filter_sensitive(&l));
            (detected, filtered_line)
        } else {
            (false, None)
        };

        Some(AppContext {
            app_name,
            terminal,
            console_detected,
            console_last_line,
        })
    }
    ```

    4. Wrap in timeout (update the existing `detect()` to become `detect_app_context_with_timeout`):
    ```rust
    /// Public API: app context detection with 500ms hard timeout.
    pub fn detect_full(previous_app_pid: i32) -> Option<AppContext> {
        let (tx, rx) = mpsc::channel();
        std::thread::spawn(move || {
            let result = detect_app_context(previous_app_pid);
            let _ = tx.send(result);
        });
        rx.recv_timeout(Duration::from_millis(500)).ok().flatten()
    }
    ```

    KEEP the existing `detect()` function intact (Plan 03-03 may still reference it through `get_terminal_context`). Add the new `detect_full()` as the new public API.

    **commands/terminal.rs:** Add a new IPC command alongside the existing one:
    ```rust
    #[tauri::command]
    pub fn get_app_context(app: AppHandle) -> Option<terminal::AppContext> {
        let pid = app
            .try_state::<AppState>()?
            .previous_app_pid
            .lock()
            .ok()?
            .clone()?;

        terminal::detect_full(pid)
    }
    ```

    Register `get_app_context` in `src-tauri/src/lib.rs` generate_handler (add it alongside existing get_terminal_context).
    Add capability permission for the new command.

    Keep `get_terminal_context` as-is for backward compatibility (Plan 03-03 uses it). Plan 03-05 (frontend update) will switch the frontend to use `get_app_context` instead.
  </action>
  <verify>
    Run `cd src-tauri && cargo check` -- must compile with zero errors.
    Run `cd src-tauri && cargo clippy -- -W clippy::all` -- no errors.
    Verify browser module: `ls src-tauri/src/terminal/browser.rs`.
    Verify AppContext struct: `grep "pub struct AppContext" src-tauri/src/terminal/mod.rs`.
    Verify new IPC command: `grep "get_app_context" src-tauri/src/commands/terminal.rs`.
    Verify IPC registration: `grep "get_app_context" src-tauri/src/lib.rs`.
    Verify console detection: `grep "detect_console" src-tauri/src/terminal/browser.rs`.
    Verify detect_full: `grep "detect_full" src-tauri/src/terminal/mod.rs`.
  </verify>
  <done>
    browser.rs detects DevTools/Console open in Chrome/Safari/Firefox/Arc/Edge/Brave via AX tree title heuristic, reads last console line. AppContext struct wraps app_name + terminal context + console state. detect_full() orchestrates all context types with 500ms timeout. get_app_context IPC command registered. `cargo check` and `cargo clippy` pass.
  </done>
</task>

</tasks>

<verification>
1. `cargo check` passes with browser.rs and AppContext struct
2. `cargo clippy` reports no errors
3. get_app_display_name resolves localized app name from PID via ObjC FFI
4. clean_app_name shortens common app names (Chrome, Code, Firefox, Edge, Brave)
5. Browser bundle IDs detected for Chrome, Safari, Firefox, Arc, Edge, Brave
6. Console detection walks AX tree for DevTools/Web Inspector window titles
7. Only last line of console output is captured (not full text)
8. Sensitive data filtered from console last line
9. AppContext includes app_name, terminal context, console state
10. detect_full() has 500ms hard timeout
11. get_app_context IPC command registered and callable
12. Existing get_terminal_context command unchanged (backward compatible)
</verification>

<success_criteria>
- AppContext returned for ANY frontmost app (not just terminals)
- App display name resolved and cleaned for all apps
- Browser console detection works via AX tree heuristic
- Last console line captured and filtered
- Full backward compatibility with existing get_terminal_context
- No compilation errors or clippy errors
</success_criteria>

<output>
After completion, create `.planning/phases/03-terminal-context-reading/03-04-SUMMARY.md`
</output>
