---
phase: 03-terminal-context-reading
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src-tauri/Cargo.toml
  - src-tauri/src/state.rs
  - src-tauri/src/commands/hotkey.rs
  - src-tauri/src/commands/window.rs
  - src-tauri/src/terminal/mod.rs
  - src-tauri/src/terminal/detect.rs
  - src-tauri/src/terminal/process.rs
  - src-tauri/src/commands/terminal.rs
  - src-tauri/src/commands/mod.rs
  - src-tauri/src/lib.rs
autonomous: true
requirements: [TERM-02, TERM-04]

must_haves:
  truths:
    - "get_terminal_context IPC command returns TerminalContext struct with cwd, shell_type, running_process fields"
    - "Detection identifies all 5 terminals by bundle ID (com.apple.Terminal, com.googlecode.iterm2, io.alacritty, net.kovidgoyal.kitty, com.github.wez.wezterm)"
    - "CWD is read via darwin-libproc pid_cwd for the foreground shell process"
    - "Shell type is derived from actual running process binary name, not $SHELL"
    - "Previous frontmost app PID is captured BEFORE panel show_and_make_key"
    - "When frontmost app is not a terminal, get_terminal_context returns None/null"
    - "tmux/screen process hierarchy is walked to find actual shell PID"
  artifacts:
    - path: "src-tauri/src/terminal/mod.rs"
      provides: "TerminalContext struct definition and pub fn detect()"
      contains: "pub struct TerminalContext"
    - path: "src-tauri/src/terminal/detect.rs"
      provides: "Frontmost app detection via bundle ID matching"
      contains: "TERMINAL_BUNDLE_IDS"
    - path: "src-tauri/src/terminal/process.rs"
      provides: "Process inspection: CWD, shell type, running process, tmux walk"
      contains: "pid_cwd"
    - path: "src-tauri/src/commands/terminal.rs"
      provides: "get_terminal_context Tauri IPC command"
      exports: ["get_terminal_context"]
  key_links:
    - from: "src-tauri/src/commands/hotkey.rs"
      to: "src-tauri/src/state.rs"
      via: "previous_app_pid captured before toggle_overlay"
      pattern: "previous_app_pid"
    - from: "src-tauri/src/commands/terminal.rs"
      to: "src-tauri/src/terminal/mod.rs"
      via: "detect() called with previous_app_pid from AppState"
      pattern: "terminal::detect"
    - from: "src-tauri/src/terminal/process.rs"
      to: "darwin_libproc"
      via: "pid_cwd and pid_path for CWD and shell type"
      pattern: "darwin_libproc::pid_cwd"
---

<objective>
Rust backend for terminal detection: dependencies, AppState PID capture, process inspection module, and IPC command.

Purpose: Establish the core detection pipeline that identifies the frontmost terminal, walks its process tree (including tmux/screen), and reads CWD + shell type + running process via darwin-libproc. This is the foundation that Plan 02 (AX text reading) and Plan 03 (frontend integration) build on.

Output: `terminal/` Rust module with detect + process submodules, `get_terminal_context` IPC command, AppState capturing previous frontmost app PID before overlay show.
</objective>

<execution_context>
@/Users/lakshmanturlapati/.claude/get-shit-done/workflows/execute-plan.md
@/Users/lakshmanturlapati/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-terminal-context-reading/03-RESEARCH.md
@.planning/phases/01-foundation-overlay/01-01-SUMMARY.md
@.planning/phases/02-settings-configuration/02-01-SUMMARY.md

Key existing files to understand:
@src-tauri/src/state.rs (AppState -- add previous_app_pid field)
@src-tauri/src/commands/hotkey.rs (hotkey handler -- capture PID before toggle)
@src-tauri/src/commands/window.rs (show_overlay/toggle_overlay -- PID capture point)
@src-tauri/src/commands/permissions.rs (extern "C" FFI pattern for AXIsProcessTrusted)
@src-tauri/src/commands/mod.rs (add terminal module)
@src-tauri/src/lib.rs (register get_terminal_context in invoke_handler)
@src-tauri/Cargo.toml (add darwin-libproc, accessibility-sys, regex)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add dependencies, extend AppState, capture previous frontmost app PID in hotkey handler</name>
  <files>
    src-tauri/Cargo.toml
    src-tauri/src/state.rs
    src-tauri/src/commands/hotkey.rs
    src-tauri/src/commands/window.rs
  </files>
  <action>
    **Cargo.toml:** Add these dependencies:
    ```toml
    darwin-libproc = "0.2"
    accessibility-sys = "0.2"
    regex = "1"
    once_cell = "1"
    ```
    Note: `once_cell` is needed for `Lazy` static regex patterns in Plan 02's filter.rs.

    **state.rs:** Add a new field to AppState:
    ```rust
    /// PID of the frontmost app captured BEFORE showing overlay.
    /// Populated in hotkey handler before show_and_make_key().
    /// Used by get_terminal_context to detect which terminal was active.
    pub previous_app_pid: Mutex<Option<i32>>,
    ```
    Initialize it as `Mutex::new(None)` in `Default` impl.

    **hotkey.rs:** In the hotkey handler closure (inside `on_shortcut`), BEFORE calling `toggle_overlay(&app_handle)`:
    1. Check if the overlay is currently hidden (about to show). Read `overlay_visible` from AppState.
    2. If overlay is hidden (about to show), capture the frontmost application PID using NSWorkspace:
       ```rust
       #[cfg(target_os = "macos")]
       {
           extern "C" {
               fn NSWorkspaceFrontmostApplicationPID() -> i32;
           }
       }
       ```
       Actually, NSWorkspace does not expose a simple C function. Use the objc runtime pattern instead:
       - Use `extern "C"` block with objc_msgSend to call `[NSWorkspace sharedWorkspace].frontmostApplication.processIdentifier`
       - OR use `std::process::Command::new("lsappinfo").arg("front")` which is simpler
       - The BEST approach per research: Use the `cocoa` crate (already available via tauri-nspanel dependency) or raw objc FFI.

       Simplest reliable approach: Use the `objc2` pattern already established (the project uses raw FFI). Create a helper function `get_frontmost_pid()` that:
       ```rust
       #[cfg(target_os = "macos")]
       fn get_frontmost_pid() -> Option<i32> {
           use std::ffi::c_void;
           extern "C" {
               fn objc_getClass(name: *const u8) -> *mut c_void;
               fn sel_registerName(name: *const u8) -> *mut c_void;
               fn objc_msgSend(receiver: *mut c_void, sel: *mut c_void, ...) -> *mut c_void;
           }
           unsafe {
               let workspace_class = objc_getClass(b"NSWorkspace\0".as_ptr());
               let shared_sel = sel_registerName(b"sharedWorkspace\0".as_ptr());
               let workspace = objc_msgSend(workspace_class, shared_sel);
               if workspace.is_null() { return None; }

               let front_sel = sel_registerName(b"frontmostApplication\0".as_ptr());
               let front_app = objc_msgSend(workspace, front_sel);
               if front_app.is_null() { return None; }

               let pid_sel = sel_registerName(b"processIdentifier\0".as_ptr());
               let pid = objc_msgSend(front_app, pid_sel) as i32;
               if pid > 0 { Some(pid) } else { None }
           }
       }
       ```
       Place this helper in `hotkey.rs` (or in a shared util, but hotkey.rs is the only caller so keep it local).

    3. Store the captured PID in `AppState.previous_app_pid`:
       ```rust
       if !is_visible {
           if let Some(pid) = get_frontmost_pid() {
               if let Some(state) = app_handle.try_state::<AppState>() {
                   if let Ok(mut prev) = state.previous_app_pid.lock() {
                       *prev = Some(pid);
                   }
               }
           }
       }
       ```

    **window.rs:** In `show_overlay`, AFTER `panel.show_and_make_key()`, emit an event to the frontend that carries the detection trigger:
    ```rust
    let _ = app.emit("overlay-shown", ());
    ```
    This event already exists. No change needed here -- the frontend will call `get_terminal_context` in response to `overlay-shown` (Plan 03).

    IMPORTANT: The PID capture MUST happen in the hotkey handler BEFORE `toggle_overlay` is called. After `show_and_make_key()`, `NSWorkspace.frontmostApplication` returns our own app. This is Pitfall 1 from the research.
  </action>
  <verify>
    Run `cd src-tauri && cargo check` -- must compile with zero errors.
    Verify `previous_app_pid` field exists in AppState with `grep -n "previous_app_pid" src-tauri/src/state.rs`.
    Verify `get_frontmost_pid` is called in hotkey handler with `grep -n "get_frontmost_pid\|previous_app_pid" src-tauri/src/commands/hotkey.rs`.
  </verify>
  <done>
    AppState has previous_app_pid field. Hotkey handler captures frontmost app PID before toggling overlay. darwin-libproc, accessibility-sys, regex, once_cell in Cargo.toml. `cargo check` passes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create terminal detection module with process inspection and IPC command</name>
  <files>
    src-tauri/src/terminal/mod.rs
    src-tauri/src/terminal/detect.rs
    src-tauri/src/terminal/process.rs
    src-tauri/src/commands/terminal.rs
    src-tauri/src/commands/mod.rs
    src-tauri/src/lib.rs
  </files>
  <action>
    **terminal/mod.rs:** Define the core TerminalContext struct and orchestration:
    ```rust
    pub mod detect;
    pub mod process;

    use serde::Serialize;

    #[derive(Debug, Clone, Serialize)]
    pub struct TerminalContext {
        pub shell_type: Option<String>,      // "zsh", "bash", "fish"
        pub cwd: Option<String>,             // "/Users/foo/projects/bar"
        pub visible_output: Option<String>,  // filtered terminal text (populated by Plan 02)
        pub running_process: Option<String>, // "node", "python" if not just the shell
    }

    /// Main detection entry point. Returns None if frontmost app is not a terminal.
    /// visible_output will always be None in this plan -- Plan 02 adds AX text reading.
    pub fn detect(previous_app_pid: i32) -> Option<TerminalContext> {
        // 1. Get bundle ID of previous frontmost app
        let bundle_id = detect::get_bundle_id(previous_app_pid)?;

        // 2. Check if it is a known terminal
        if !detect::is_known_terminal(&bundle_id) {
            return None; // Not a terminal -- overlay works without context
        }

        // 3. Find foreground process (shell or running command)
        let proc_info = process::get_foreground_info(previous_app_pid);

        Some(TerminalContext {
            shell_type: proc_info.shell_type,
            cwd: proc_info.cwd,
            visible_output: None, // Plan 02 adds AX text reading
            running_process: proc_info.running_process,
        })
    }
    ```

    **terminal/detect.rs:** Bundle ID detection using NSRunningApplication:
    ```rust
    const TERMINAL_BUNDLE_IDS: &[&str] = &[
        "com.apple.Terminal",
        "com.googlecode.iterm2",
        "io.alacritty",
        "net.kovidgoyal.kitty",
        "com.github.wez.wezterm",
    ];

    pub fn is_known_terminal(bundle_id: &str) -> bool {
        TERMINAL_BUNDLE_IDS.contains(&bundle_id)
    }

    pub fn is_gpu_terminal(bundle_id: &str) -> bool {
        matches!(bundle_id, "io.alacritty" | "net.kovidgoyal.kitty" | "com.github.wez.wezterm")
    }

    /// Get the bundle identifier of a running application by PID.
    /// Uses NSRunningApplication via objc FFI (same pattern as AXIsProcessTrusted in permissions.rs).
    #[cfg(target_os = "macos")]
    pub fn get_bundle_id(pid: i32) -> Option<String> {
        use std::ffi::c_void;
        extern "C" {
            fn objc_getClass(name: *const u8) -> *mut c_void;
            fn sel_registerName(name: *const u8) -> *mut c_void;
            fn objc_msgSend(receiver: *mut c_void, sel: *mut c_void, ...) -> *mut c_void;
        }
        unsafe {
            // [NSRunningApplication runningApplicationWithProcessIdentifier:pid]
            let cls = objc_getClass(b"NSRunningApplication\0".as_ptr());
            let sel = sel_registerName(b"runningApplicationWithProcessIdentifier:\0".as_ptr());
            let app = objc_msgSend(cls, sel, pid);
            if app.is_null() { return None; }

            // [app bundleIdentifier]
            let bundle_sel = sel_registerName(b"bundleIdentifier\0".as_ptr());
            let ns_string = objc_msgSend(app, bundle_sel);
            if ns_string.is_null() { return None; }

            // Convert NSString to Rust String via UTF8String
            let utf8_sel = sel_registerName(b"UTF8String\0".as_ptr());
            let c_str = objc_msgSend(ns_string, utf8_sel) as *const i8;
            if c_str.is_null() { return None; }

            Some(std::ffi::CStr::from_ptr(c_str).to_string_lossy().into_owned())
        }
    }

    #[cfg(not(target_os = "macos"))]
    pub fn get_bundle_id(_pid: i32) -> Option<String> {
        None
    }
    ```

    **terminal/process.rs:** Process inspection via darwin-libproc:
    ```rust
    use darwin_libproc;

    pub struct ProcessInfo {
        pub cwd: Option<String>,
        pub shell_type: Option<String>,
        pub running_process: Option<String>,
    }

    /// Known shell binary names for identifying shell vs running process.
    const KNOWN_SHELLS: &[&str] = &["bash", "zsh", "fish", "sh", "dash", "tcsh", "csh", "ksh", "nu", "elvish", "ion", "xonsh"];
    /// Process names that indicate a multiplexer (tmux, screen) requiring deeper walk.
    const MULTIPLEXERS: &[&str] = &["tmux", "screen"];

    /// Get CWD, shell type, and running process for the foreground process in a terminal.
    pub fn get_foreground_info(terminal_pid: i32) -> ProcessInfo {
        // Walk child processes from terminal PID to find the shell
        let shell_pid = find_shell_pid(terminal_pid);

        let shell_pid = match shell_pid {
            Some(pid) => pid,
            None => return ProcessInfo { cwd: None, shell_type: None, running_process: None },
        };

        // Get CWD from the shell process (works for all 5 terminals)
        let cwd = darwin_libproc::pid_cwd(shell_pid)
            .ok()
            .map(|p| p.to_string_lossy().into_owned());

        // Get shell type from actual binary name (not $SHELL env var -- Pitfall 7)
        let shell_name = get_process_name(shell_pid);
        let shell_type = shell_name.clone();

        // Check if there is a foreground process running INSIDE the shell
        // (e.g., `node server.js`, `python script.py`)
        let running_process = find_running_process(shell_pid, &shell_name);

        ProcessInfo { cwd, shell_type, running_process }
    }

    /// Find the shell PID by walking child processes from terminal PID.
    /// Handles tmux/screen: if direct child is a multiplexer, walks deeper.
    fn find_shell_pid(terminal_pid: i32) -> Option<i32> {
        // Get direct children of terminal app
        let children = darwin_libproc::ppid_only_pids(terminal_pid).ok()?;
        if children.is_empty() { return None; }

        for child in &children {
            let name = get_process_name(*child);
            if let Some(ref n) = name {
                // If child is a multiplexer, walk deeper (max 3 levels per Pitfall 6)
                if MULTIPLEXERS.iter().any(|m| n.contains(m)) {
                    if let Some(shell) = walk_multiplexer_tree(*child, 3) {
                        return Some(shell);
                    }
                }
                // If child is a known shell, return it directly
                if KNOWN_SHELLS.contains(&n.as_str()) {
                    return Some(*child);
                }
            }
        }

        // Fallback: return first child (might be login shell or wrapper)
        Some(children[0])
    }

    /// Walk process tree through multiplexer layers to find actual shell.
    /// max_depth prevents infinite recursion.
    fn walk_multiplexer_tree(parent_pid: i32, max_depth: u32) -> Option<i32> {
        if max_depth == 0 { return None; }

        let children = darwin_libproc::ppid_only_pids(parent_pid).ok()?;
        for child in &children {
            let name = get_process_name(*child);
            if let Some(ref n) = name {
                if KNOWN_SHELLS.contains(&n.as_str()) {
                    return Some(*child);
                }
                if MULTIPLEXERS.iter().any(|m| n.contains(m)) {
                    if let Some(shell) = walk_multiplexer_tree(*child, max_depth - 1) {
                        return Some(shell);
                    }
                }
            }
        }

        // If no shell found, return first child as fallback
        children.first().copied()
    }

    /// Find running process inside shell (child of shell that is not a shell).
    /// Returns process name if a non-shell child exists (e.g., "node", "python").
    fn find_running_process(shell_pid: i32, shell_name: &Option<String>) -> Option<String> {
        let children = darwin_libproc::ppid_only_pids(shell_pid).ok()?;
        for child in &children {
            let name = get_process_name(*child);
            if let Some(ref n) = name {
                // Skip if same as shell
                if shell_name.as_ref().map_or(false, |s| s == n) { continue; }
                return Some(n.clone());
            }
        }
        None
    }

    /// Get process name from PID using darwin-libproc pid_path.
    /// Extracts just the binary filename from the full path.
    fn get_process_name(pid: i32) -> Option<String> {
        darwin_libproc::pid_path(pid)
            .ok()
            .and_then(|p| p.file_name().map(|n| n.to_string_lossy().into_owned()))
    }
    ```

    **commands/terminal.rs:** Tauri IPC command:
    ```rust
    use tauri::{AppHandle, Manager};
    use crate::state::AppState;
    use crate::terminal;

    /// Get terminal context (CWD, shell type, running process, visible output).
    /// Called by frontend when overlay is shown. Returns null if frontmost app is not a terminal.
    #[tauri::command]
    pub fn get_terminal_context(app: AppHandle) -> Option<terminal::TerminalContext> {
        // Read the previously captured frontmost app PID
        let pid = app
            .try_state::<AppState>()?
            .previous_app_pid
            .lock()
            .ok()?
            .clone()?;

        terminal::detect(pid)
    }
    ```

    **commands/mod.rs:** Add `pub mod terminal;`

    **lib.rs:**
    1. Add `mod terminal;` at top level (alongside `mod commands; mod state;`)
    2. Add `use commands::terminal::get_terminal_context;` to imports
    3. Add `get_terminal_context` to the `generate_handler![]` macro call
    4. Add `get_terminal_context` to capabilities/default.json if needed (Tauri v2 IPC permissions)

    **capabilities/default.json:** Add `"terminal:get_terminal_context"` or just ensure the command is allowed. In Tauri v2, IPC commands need to be explicitly allowed. Check existing pattern from other commands and follow it.
  </action>
  <verify>
    Run `cd src-tauri && cargo check` -- must compile with zero errors.
    Run `cd src-tauri && cargo clippy -- -W clippy::all` -- no errors (warnings acceptable).
    Verify module structure: `ls src-tauri/src/terminal/` should show mod.rs, detect.rs, process.rs.
    Verify IPC registration: `grep "get_terminal_context" src-tauri/src/lib.rs` should show it in generate_handler.
    Verify TerminalContext struct is Serialize: `grep "Serialize" src-tauri/src/terminal/mod.rs`.
  </verify>
  <done>
    terminal/ module exists with detect.rs (bundle ID matching for 5 terminals), process.rs (CWD via darwin-libproc, shell type from binary name, tmux walk, running process detection), and mod.rs (TerminalContext struct with detect() orchestrator). get_terminal_context IPC command registered and compiles. `cargo check` passes.
  </done>
</task>

</tasks>

<verification>
1. `cargo check` passes with all new code
2. `cargo clippy` reports no errors
3. AppState.previous_app_pid is populated before toggle_overlay in hotkey handler
4. get_terminal_context command is registered in lib.rs generate_handler
5. TerminalContext struct has shell_type, cwd, visible_output (None for now), running_process fields
6. TERMINAL_BUNDLE_IDS contains all 5 terminal bundle IDs
7. darwin-libproc, accessibility-sys, regex, once_cell listed in Cargo.toml dependencies
</verification>

<success_criteria>
- Rust compiles cleanly with new terminal detection module
- get_terminal_context IPC command is callable from frontend (returns null for non-terminal or TerminalContext for terminals)
- CWD is read via darwin-libproc for the foreground shell process
- Shell type derived from actual binary name, not $SHELL env var
- tmux/screen hierarchy walked up to 3 levels deep
- Previous app PID captured before panel show
</success_criteria>

<output>
After completion, create `.planning/phases/03-terminal-context-reading/03-01-SUMMARY.md`
</output>
