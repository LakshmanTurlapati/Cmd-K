---
phase: 10-ai-follow-up-context-per-window
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/store/index.ts
  - src-tauri/src/state.rs
  - src-tauri/src/commands/ai.rs
autonomous: true
requirements: [CTXT-01, CTXT-02, CTXT-03]

must_haves:
  truths:
    - "User submits a query, dismisses overlay, reopens on same terminal window, and the AI sees the prior exchange in its history"
    - "User on terminal window A gets window A history; switching to window B gets window B history -- no cross-contamination"
    - "Follow-up messages sent to the AI do not include terminal context (CWD, shell, output) -- only the first message of a session includes it"
    - "Hardcoded 14-message / 7-turn cap is replaced with configurable turnLimit from Zustand state"
  artifacts:
    - path: "src/store/index.ts"
      provides: "turnHistory reconstruction from windowHistory on overlay open, turnLimit state, setTurnHistory/setTurnLimit actions, removed turnHistory reset from show()"
      contains: "setTurnHistory"
    - path: "src-tauri/src/state.rs"
      provides: "MAX_HISTORY_PER_WINDOW increased to 50"
      contains: "MAX_HISTORY_PER_WINDOW: usize = 50"
    - path: "src-tauri/src/commands/ai.rs"
      provides: "Conditional terminal context: first message gets full context, follow-ups get query only"
      contains: "is_follow_up"
  key_links:
    - from: "src/store/index.ts (show)"
      to: "windowHistory -> turnHistory"
      via: "flatMap reconstruction filtering is_error entries"
      pattern: "flatMap.*role.*user.*assistant"
    - from: "src/store/index.ts (submitQuery)"
      to: "turnLimit"
      via: "turnLimit * 2 replaces hardcoded 14"
      pattern: "turnLimit.*\\*.*2"
    - from: "src-tauri/src/commands/ai.rs"
      to: "build_user_message"
      via: "is_follow_up flag based on history.is_empty()"
      pattern: "is_follow_up"
---

<objective>
Wire per-window conversation persistence so the AI sees prior exchanges on overlay reopen, and conditionally include terminal context only in the first message of a session.

Purpose: This is the core of Phase 10 -- without it, every overlay open starts a fresh AI conversation with no memory of prior exchanges on the same terminal window.

Output: Modified Zustand store with turnHistory reconstruction, updated Rust AI prompt builder with follow-up detection, increased history storage cap.
</objective>

<execution_context>
@/Users/lakshmanturlapati/.claude/get-shit-done/workflows/execute-plan.md
@/Users/lakshmanturlapati/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-ai-follow-up-context-per-window/10-RESEARCH.md
@.planning/phases/08-window-identification-history-storage/08-01-SUMMARY.md
@.planning/phases/08-window-identification-history-storage/08-02-SUMMARY.md

Key source files:
@src/store/index.ts
@src-tauri/src/commands/ai.rs
@src-tauri/src/state.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Zustand store -- turnHistory reconstruction, turnLimit state, remove reset</name>
  <files>src/store/index.ts, src-tauri/src/state.rs</files>
  <action>
**1. Increase MAX_HISTORY_PER_WINDOW in state.rs:**
Change `pub const MAX_HISTORY_PER_WINDOW: usize = 7;` to `pub const MAX_HISTORY_PER_WINDOW: usize = 50;` so the Rust-side storage matches the configurable turn limit slider max (5-50). Memory impact is negligible (~100KB per window at 50 entries).

**2. Add turnLimit state and actions to the Zustand store (src/store/index.ts):**

In the `OverlayState` interface, add:
- `turnLimit: number;` (default 7)
- `setTurnLimit: (limit: number) => void;`
- `setTurnHistory: (history: TurnMessage[]) => void;`

In the store initialization (create block), add:
- `turnLimit: 7,`
- `setTurnLimit: (limit) => set({ turnLimit: limit }),`
- `setTurnHistory: (history) => set({ turnHistory: history }),`

**3. Remove `turnHistory: []` from the show() synchronous setter:**
In the `show()` action, the `set()` call currently resets `turnHistory: []`. REMOVE that line. TurnHistory will be reconstructed in the async block after windowHistory is fetched.

**4. Reconstruct turnHistory from windowHistory in show() async block:**
After the existing `setWindowHistory(history)` call inside the `if (windowKey)` block, add turnHistory reconstruction:

```typescript
// Reconstruct turnHistory from stored entries (CTXT-01, CTXT-02)
const turnLimit = useOverlayStore.getState().turnLimit;
const turnMessages: TurnMessage[] = history
  .filter(e => !e.is_error && e.response)
  .flatMap(e => [
    { role: "user" as const, content: e.query },
    { role: "assistant" as const, content: e.response },
  ]);
const maxMessages = turnLimit * 2;
const trimmed = turnMessages.length > maxMessages
  ? turnMessages.slice(turnMessages.length - maxMessages)
  : turnMessages;
useOverlayStore.getState().setTurnHistory(trimmed);
```

In the `else` branch (no windowKey), add: `useOverlayStore.getState().setTurnHistory([]);`

**5. Replace hardcoded 14-message cap in submitQuery:**
In submitQuery, find the block that builds `updatedHistory` and `trimmedHistory` with the hardcoded `> 14` check (around lines 462-465). Replace with:

```typescript
const currentTurnLimit = useOverlayStore.getState().turnLimit;
const maxMessages = currentTurnLimit * 2;
const trimmedHistory =
  updatedHistory.length > maxMessages
    ? updatedHistory.slice(updatedHistory.length - maxMessages)
    : updatedHistory;
```

This replaces the hardcoded `14` with `turnLimit * 2`.
  </action>
  <verify>
Run `cd src-tauri && cargo check` to verify Rust compiles.
Run `cd src && npx tsc --noEmit` (or the project's TS check command) to verify TypeScript compiles.
Grep for `turnHistory: []` in show() -- should NOT appear.
Grep for `> 14` in submitQuery -- should NOT appear.
Grep for `MAX_HISTORY_PER_WINDOW: usize = 50` in state.rs -- should appear.
  </verify>
  <done>
turnHistory is no longer reset on overlay open. It is reconstructed from windowHistory entries (filtering out errors) after each show(). The hardcoded 14-message cap is replaced with configurable turnLimit. MAX_HISTORY_PER_WINDOW is 50.
  </done>
</task>

<task type="auto">
  <name>Task 2: Rust AI prompt -- conditional terminal context for follow-ups</name>
  <files>src-tauri/src/commands/ai.rs</files>
  <action>
**1. Add `is_follow_up` parameter to `build_user_message`:**
Change the signature from:
```rust
fn build_user_message(query: &str, ctx: &AppContextView) -> String {
```
to:
```rust
fn build_user_message(query: &str, ctx: &AppContextView, is_follow_up: bool) -> String {
```

**2. Add early return for follow-up messages at the top of `build_user_message`:**
After the `is_terminal_mode` check, add:
```rust
if is_follow_up {
    // Follow-up: just the query, no terminal context (CTXT-03)
    // System prompt already has shell type from the first message
    if is_terminal_mode {
        return format!("Task: {}", query);
    } else {
        return query.to_string();
    }
}
```
The rest of the function (existing first-message logic) stays unchanged.

**3. Update the `build_user_message` call site in `stream_ai_response`:**
Before the call to `build_user_message`, determine if this is a follow-up:
```rust
let is_follow_up = !history.is_empty();
```
Then update the call:
```rust
let user_message = build_user_message(&query, &ctx, is_follow_up);
```

**4. Remove the hardcoded 14-message history cap in `stream_ai_response`:**
Replace:
```rust
let history_start = history.len().saturating_sub(14);
```
with just using the full history array as-is (frontend already caps it via turnLimit):
```rust
for msg in &history {
    messages.push(serde_json::json!({
        "role": msg.role,
        "content": msg.content
    }));
}
```
Remove the `history_start` variable and the `history[history_start..]` slice. The frontend passes a pre-capped array so no Rust-side capping is needed.

Update the comment above (line ~184) from "Cap history to last 7 turns" to reflect that the frontend handles capping.
  </action>
  <verify>
Run `cd src-tauri && cargo check` to verify Rust compiles with zero errors.
Grep for `is_follow_up` in ai.rs -- should appear in build_user_message signature and stream_ai_response.
Grep for `saturating_sub(14)` in ai.rs -- should NOT appear.
  </verify>
  <done>
build_user_message accepts is_follow_up flag. Follow-up messages contain only the query text ("Task: {query}" for terminal mode, raw query for assistant mode) with no terminal context. The hardcoded 14-message Rust-side cap is removed; frontend sends pre-capped history.
  </done>
</task>

</tasks>

<verification>
1. `cargo check` passes in src-tauri/ with zero errors
2. TypeScript compilation passes with zero errors
3. No `turnHistory: []` in show() synchronous setter
4. No hardcoded `14` or `saturating_sub(14)` in ai.rs or submitQuery
5. `MAX_HISTORY_PER_WINDOW` is 50 in state.rs
6. `build_user_message` has 3 parameters (query, ctx, is_follow_up)
7. turnHistory reconstruction uses `.filter(e => !e.is_error && e.response)` to exclude error entries
</verification>

<success_criteria>
- Conversation history persists across overlay open/close cycles for the same terminal window (CTXT-01)
- turnHistory is reconstructed from windowHistory on overlay open (CTXT-02)
- Follow-up messages to the AI omit terminal context; only the first message includes it (CTXT-03)
- Configurable turn limit replaces all hardcoded caps
</success_criteria>

<output>
After completion, create `.planning/phases/10-ai-follow-up-context-per-window/10-01-SUMMARY.md`
</output>
