---
phase: 09-arrow-key-history-navigation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/hooks/useHistoryNavigation.ts
  - src/components/CommandInput.tsx
  - src/store/index.ts
autonomous: true
requirements: [HIST-01, HIST-02, HIST-03]

must_haves:
  truths:
    - "Arrow-Up in empty overlay input recalls the most recent query for the active terminal window"
    - "Arrow-Up again recalls the second-most-recent query, continuing backward through history"
    - "Arrow-Down after navigating up moves forward through history entries"
    - "Arrow-Down past the newest history entry restores the user's draft text"
    - "If the user types partial text and then presses Arrow-Up, the draft is preserved and restored when Arrow-Down goes past the end"
    - "Recalled history entries appear in slightly dimmed text color, returning to normal when the user edits"
    - "Arrow-Up at the oldest entry stays on that entry (no wrap, no feedback)"
    - "Arrow-Down past the newest entry restores draft and stops (no cycling)"
    - "Arrow-Up with no history is a silent no-op"
    - "Arrow-Up in multi-line input only triggers history when cursor is on the first line"
    - "Arrow-Down always navigates history regardless of cursor position (asymmetric with Arrow-Up)"
    - "History index resets on submit so next Arrow-Up starts from the most recent query"
    - "After submitting a query, Arrow-Up immediately sees the just-submitted query without reopening overlay"
  artifacts:
    - path: "src/hooks/useHistoryNavigation.ts"
      provides: "History navigation hook with index, draft preservation, keyboard event handling"
      min_lines: 60
    - path: "src/components/CommandInput.tsx"
      provides: "Textarea with arrow-key history and dimmed text styling"
      contains: "useHistoryNavigation"
    - path: "src/store/index.ts"
      provides: "windowHistory sync after submit"
      contains: "setWindowHistory"
  key_links:
    - from: "src/hooks/useHistoryNavigation.ts"
      to: "src/store/index.ts"
      via: "useOverlayStore.getState().windowHistory read and setInputValue write"
      pattern: "useOverlayStore\\.getState\\(\\)"
    - from: "src/components/CommandInput.tsx"
      to: "src/hooks/useHistoryNavigation.ts"
      via: "import and call useHistoryNavigation hook"
      pattern: "useHistoryNavigation"
    - from: "src/store/index.ts"
      to: "src/store/index.ts"
      via: "submitQuery appends to windowHistory after add_history_entry"
      pattern: "setWindowHistory"
---

<objective>
Implement arrow-key history navigation in the overlay input so users can recall previous queries using Arrow-Up/Down, just like shell history. The history data already exists in Zustand (windowHistory, populated by Phase 8). This plan adds the navigation logic, draft preservation, dimmed text styling, and keeps the local history in sync after each submit.

Purpose: Enable muscle-memory query recall without retyping -- the core HIST-01/02/03 requirements.
Output: Working arrow-key navigation in the overlay input with visual feedback for recalled entries.
</objective>

<execution_context>
@/Users/lakshmanturlapati/.claude/get-shit-done/workflows/execute-plan.md
@/Users/lakshmanturlapati/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-arrow-key-history-navigation/09-CONTEXT.md
@.planning/phases/09-arrow-key-history-navigation/09-RESEARCH.md
@.planning/phases/08-window-identification-history-storage/08-02-SUMMARY.md
@src/components/CommandInput.tsx
@src/store/index.ts
@src/hooks/useKeyboard.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create useHistoryNavigation hook and integrate into CommandInput with dimmed text styling</name>
  <files>
    src/hooks/useHistoryNavigation.ts
    src/components/CommandInput.tsx
  </files>
  <action>
    **1. Create `src/hooks/useHistoryNavigation.ts`:**

    Create a custom React hook that encapsulates all history navigation state and logic. The hook manages:

    - `historyIndex` (useState): -1 means "not navigating" (showing draft/fresh input). 0 = most recent query, 1 = second most recent, etc. Maps to `windowHistory[windowHistory.length - 1 - historyIndex]`.
    - `isRecalled` (useState): true when displaying a history entry (for dimming). Set false on edit or when draft is restored.
    - `draftRef` (useRef): saves the user's current input text on the first Arrow-Up press. Using useRef (not useState) because the draft does not need to trigger re-renders and it must survive React reconciliation within the same mount cycle.

    The hook exports:
    ```typescript
    interface UseHistoryNavigationReturn {
      isRecalled: boolean;
      handleHistoryKey: (e: React.KeyboardEvent<HTMLTextAreaElement>, textareaEl: HTMLTextAreaElement) => boolean;
      resetOnSubmit: () => void;
      markEdited: () => void;
    }
    ```

    `handleHistoryKey` implementation:

    **Arrow-Up:**
    - Check if cursor is on the first line: `!el.value.substring(0, el.selectionStart).includes("\n")`. If NOT on first line, return false (let native cursor-up happen).
    - Call `e.preventDefault()`.
    - If `windowHistory.length === 0`, return true (silent no-op).
    - If `historyIndex === -1` (first time pressing up), save `useOverlayStore.getState().inputValue` to `draftRef.current`.
    - Compute `newIndex = Math.min(historyIndex + 1, history.length - 1)`. If already at the oldest (`historyIndex === history.length - 1`), do nothing (stay on oldest, no wrap).
    - Set `historyIndex` to `newIndex`.
    - Call `useOverlayStore.getState().setInputValue(history[history.length - 1 - newIndex].query)`.
    - Set `isRecalled` to true.
    - Return true.

    **Arrow-Down:**
    - If `historyIndex > 0`: decrement index, set input to `history[history.length - 1 - newIndex].query`, keep `isRecalled` true. Call `e.preventDefault()`. Return true.
    - If `historyIndex === 0`: restore draft from `draftRef.current`, set `historyIndex` to -1, set `isRecalled` to false. Call `e.preventDefault()`. Return true.
    - If `historyIndex === -1`: return false (let native cursor-down happen, user is not navigating history).

    `resetOnSubmit`: Set `historyIndex` to -1, `isRecalled` to false, clear `draftRef.current` to "".

    `markEdited`: If `isRecalled` is true, set it to false (removes dimming when user starts editing a recalled entry).

    Import from `@/store` (path alias already configured in the project's tsconfig).

    **2. Integrate hook into `src/components/CommandInput.tsx`:**

    Add import at top:
    ```typescript
    import { useHistoryNavigation } from "@/hooks/useHistoryNavigation";
    ```

    Call the hook at the top of the component:
    ```typescript
    const { isRecalled, handleHistoryKey, resetOnSubmit, markEdited } = useHistoryNavigation();
    ```

    Modify `handleKeyDown` -- add Arrow-Up/Down handling BEFORE existing Tab/Enter logic:
    ```typescript
    const handleKeyDown = (e: React.KeyboardEvent<HTMLTextAreaElement>) => {
      // History navigation (Arrow-Up/Down)
      if (e.key === "ArrowUp" || e.key === "ArrowDown") {
        const consumed = handleHistoryKey(e, textareaRef.current!);
        if (consumed) {
          // Auto-resize textarea after text replacement
          requestAnimationFrame(() => {
            const el = textareaRef.current;
            if (el) {
              el.style.height = "auto";
              el.style.height = `${el.scrollHeight}px`;
              // Move cursor to end
              el.selectionStart = el.selectionEnd = el.value.length;
            }
          });
          return;
        }
        return; // not consumed by history, let default textarea cursor movement happen
      }

      // Any non-navigation, non-modifier key pressed while showing recalled text: mark as edited
      if (isRecalled && !["Shift", "Control", "Alt", "Meta", "CapsLock", "Tab", "Escape"].includes(e.key)) {
        markEdited();
      }

      // existing Tab handling...
      // existing Enter handling...
    };
    ```

    In the Enter submission block (where `inputValue.trim()` succeeds), add `resetOnSubmit()` call before `onSubmit(inputValue)`:
    ```typescript
    if (inputValue.trim()) {
      resetOnSubmit();
      onSubmit(inputValue);
    }
    ```
    This applies to BOTH the `displayMode === "input"` submit path AND the `displayMode === "result"` follow-up submit path.

    **3. Add dimmed text styling to textarea:**

    Change the textarea `className` array to toggle text opacity based on `isRecalled`:
    - Replace `"text-white"` with `isRecalled ? "text-white/60" : "text-white"`.
    - This uses Tailwind opacity utilities consistent with the project's existing pattern (e.g., `text-white/40` for placeholder, `text-white/20` for ghost suggestions).
    - The dimmed state clears immediately when the user presses any text-altering key (via `markEdited` in `handleKeyDown`).

    **Things to NOT do (per user decisions):**
    - No dropdown/popup for history selection (inline replace only)
    - No animation/transition on text swap (instant replace)
    - No position indicator (no "2/7" counter)
    - No cycling/wrapping at boundaries
    - Do not persist draft across overlay close/open (local state handles this naturally)
  </action>
  <verify>
    1. `ls src/hooks/useHistoryNavigation.ts` confirms file exists.
    2. `grep -c "useHistoryNavigation" src/components/CommandInput.tsx` returns at least 2 (import + usage).
    3. `grep "text-white/60" src/components/CommandInput.tsx` confirms dimmed styling is present.
    4. `grep "handleHistoryKey" src/hooks/useHistoryNavigation.ts` confirms the function is exported.
    5. `grep "resetOnSubmit" src/components/CommandInput.tsx` confirms submit reset is wired.
    6. `grep "markEdited" src/components/CommandInput.tsx` confirms edit detection is wired.
    7. Build check: `cd src-tauri && cargo build 2>&1 | tail -5` (Rust should be untouched).
    8. Frontend type check: `npx tsc --noEmit 2>&1 | tail -10` (TypeScript should compile cleanly).
  </verify>
  <done>
    Arrow-Up in the overlay input replaces the text with the most recent query from windowHistory. Repeated Arrow-Up moves backward through history. Arrow-Down moves forward. Arrow-Down past newest restores the saved draft. Recalled entries display in dimmed text (text-white/60) that returns to normal on edit. History index resets on submit. Arrow-Up in multi-line input only triggers when cursor is on the first line. Arrow-Down always navigates history regardless of cursor position.
  </done>
</task>

<task type="auto">
  <name>Task 2: Sync windowHistory in Zustand after query submit for immediate Arrow-Up recall</name>
  <files>
    src/store/index.ts
  </files>
  <action>
    **Problem:** After `submitQuery()` calls `add_history_entry` (fire-and-forget to Rust), the `windowHistory` array in Zustand is stale -- it was fetched once in `show()` and is not updated. If the user stays in the same overlay session (e.g., submits a follow-up via returnToInput), pressing Arrow-Up will NOT show the just-submitted query.

    **Fix:** After each successful `add_history_entry` invoke (both success and error paths), append the new entry to the local `windowHistory` in Zustand. This keeps the local state in sync without requiring a re-fetch IPC call.

    **1. Success path (around line 476 in current submitQuery, after the `invoke("add_history_entry", ...)` call):**

    After the fire-and-forget `invoke("add_history_entry", ...)`, add a local sync. Since the invoke is fire-and-forget (no await), do the local sync immediately after the invoke call (before the destructive check):

    ```typescript
    // Sync local windowHistory for immediate Arrow-Up recall
    const historySync: HistoryEntry = {
      query,
      response: fullText,
      timestamp: Date.now(),
      terminal_context: historyCtx,
      is_error: false,
    };
    const currentHistory = useOverlayStore.getState().windowHistory;
    useOverlayStore.getState().setWindowHistory([...currentHistory, historySync]);
    ```

    **2. Error path (around line 548, in the catch block after `invoke("add_history_entry", ...)`):**

    Similarly, after the error case fire-and-forget invoke:

    ```typescript
    // Sync local windowHistory for error query recall
    const errorHistorySync: HistoryEntry = {
      query,
      response: "",
      timestamp: Date.now(),
      terminal_context: null,
      is_error: true,
    };
    const currentErrHistory = useOverlayStore.getState().windowHistory;
    useOverlayStore.getState().setWindowHistory([...currentErrHistory, errorHistorySync]);
    ```

    **3. Cap enforcement:** The Rust backend caps history at 7 entries per window (evicting oldest). The local sync may momentarily have more than 7 entries until the next `show()` re-fetches from Rust. This is acceptable because:
    - The hook reads from the end of the array (most recent entries), so extra old entries at the front do not cause incorrect behavior.
    - The next overlay open calls `show()` which resets `windowHistory` to the Rust-authoritative state (capped at 7).

    **Things to NOT do:**
    - Do NOT await the add_history_entry invoke -- it must remain fire-and-forget for performance.
    - Do NOT re-fetch history from Rust after each submit -- the local sync is sufficient and avoids IPC overhead.
    - Do NOT modify any Rust code.
  </action>
  <verify>
    1. `grep -c "setWindowHistory" src/store/index.ts` returns at least 4 (2 in show(), 1 in success path, 1 in error path).
    2. `grep "historySync" src/store/index.ts` confirms the sync variable exists.
    3. `grep "errorHistorySync" src/store/index.ts` confirms error path sync exists.
    4. Frontend type check: `npx tsc --noEmit 2>&1 | tail -10` (TypeScript should compile cleanly).
    5. Build check: `npm run build 2>&1 | tail -10` (full frontend build should succeed).
  </verify>
  <done>
    After submitting a query (success or error), the windowHistory in Zustand is immediately updated with the new entry. Arrow-Up in the same overlay session (without reopening) shows the just-submitted query as the most recent entry.
  </done>
</task>

</tasks>

<verification>
1. **HIST-01 (Arrow-Up recall):** Open overlay, submit a query, close overlay, reopen overlay on same window. Press Arrow-Up -- the previous query appears in the input with dimmed text. Press Arrow-Up again -- the second-most-recent query appears.
2. **HIST-02 (Arrow-Down forward + draft restore):** After pressing Arrow-Up twice, press Arrow-Down -- the more recent query appears. Press Arrow-Down again -- the user's draft text is restored with normal text color.
3. **HIST-03 (Draft preservation):** Type "hello world" in the input, press Arrow-Up (draft saved, history entry shown), press Arrow-Down past newest -- "hello world" is restored in the input.
4. **Multi-line behavior:** Type "line1", Shift+Enter, "line2". With cursor on line2, press Arrow-Up -- cursor moves up within text (native behavior). With cursor on line1, press Arrow-Up -- history navigation triggers.
5. **Dimmed styling:** Recalled history text shows at 60% opacity. Typing any character returns text to full opacity.
6. **Submit reset:** After submitting, press Arrow-Up -- it starts from the most recent query (the one just submitted).
7. **Empty history:** Open overlay on a window with no history, press Arrow-Up -- nothing happens (silent no-op).
8. **Boundary behavior:** At the oldest entry, Arrow-Up stays on that entry. Past the newest entry, Arrow-Down restores draft and stops.
</verification>

<success_criteria>
- useHistoryNavigation hook created in src/hooks/ with full navigation logic
- CommandInput.tsx integrates the hook with Arrow-Up/Down handling before existing Tab/Enter logic
- Dimmed text styling (text-white/60) applied when isRecalled is true
- windowHistory synced locally after submit in both success and error paths
- TypeScript compiles without errors
- No Rust changes required
</success_criteria>

<output>
After completion, create `.planning/phases/09-arrow-key-history-navigation/09-01-SUMMARY.md`
</output>
